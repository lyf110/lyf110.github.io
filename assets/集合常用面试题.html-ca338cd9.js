import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as d,c,a,d as l,w as s,e as n,b as e}from"./app-5f6064b2.js";const o={},u=n('<h1 id="一、集合常用面试题" tabindex="-1"><a class="header-anchor" href="#一、集合常用面试题" aria-hidden="true">#</a> 一、集合常用面试题</h1><h3 id="_1、说说-list-set-queue-map-四者的区别-四者底层的数据结构" tabindex="-1"><a class="header-anchor" href="#_1、说说-list-set-queue-map-四者的区别-四者底层的数据结构" aria-hidden="true">#</a> 1、说说 List,Set,Queue,Map 四者的区别？四者底层的数据结构？</h3><p><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</p><p><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</p><p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&quot;x&quot; 代表 key，&quot;y&quot; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p>',6),m={class:"hint-container details"},_=a("summary",null,"显示代码",-1),b=a("div",{class:"language-bash line-numbers-mode","data-ext":"sh"},[a("pre",{class:"language-bash"},[a("code",null,[a("span",{class:"token function"},"pnpm"),e(),a("span",{class:"token function"},"add"),e(),a("span",{class:"token parameter variable"},"-D"),e(` vuepress-theme-hope
`)])]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"})])],-1),H=a("div",{class:"language-bash line-numbers-mode","data-ext":"sh"},[a("pre",{class:"language-bash"},[a("code",null,[a("span",{class:"token function"},"yarn"),e(),a("span",{class:"token function"},"add"),e(),a("span",{class:"token parameter variable"},"-D"),e(` vepress-theme-hope
`)])]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"})])],-1),M=a("div",{class:"language-bash line-numbers-mode","data-ext":"sh"},[a("pre",{class:"language-bash"},[a("code",null,[a("span",{class:"token function"},"npm"),e(" i "),a("span",{class:"token parameter variable"},"-D"),e(` vuepress-theme-hope
`)])]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"})])],-1),v=n('<p>:::</p><h3 id="_2、有哪些集合是线程不安全的-怎么解决呢" tabindex="-1"><a class="header-anchor" href="#_2、有哪些集合是线程不安全的-怎么解决呢" aria-hidden="true">#</a> 2、有哪些集合是线程不安全的？怎么解决呢？</h3><p>List常用的线程不安全有ArrayList，LinkedList等，使用线程安全的集合Vector（不推荐使用）、使用Collecttions.synchronized(list)进行包装（不推荐），或者加锁（不推荐），推荐使用线程安全的集合CopyOnWriteArrayList等</p><p>Set常用的的线程不安全集合有HashSet、LinkedHashSet、TreeSet等，加锁（不推荐），推荐使用CopyOnWriteArraySet等线程安全的Set集合</p><p>Map常用的线程不安全集合有HashMap、LinkedHashMap、TreeMap，使用Hashtable（不推荐）、使用Collections.synchronizedMap(map)进行包装（不推荐）、加锁（不推荐）、使用线程安全的集合ConcurrentHashMap（推荐使用）</p><h3 id="_3、比较-hashset、linkedhashset-和-treeset-三者的异同" tabindex="-1"><a class="header-anchor" href="#_3、比较-hashset、linkedhashset-和-treeset-三者的异同" aria-hidden="true">#</a> 3、比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p>HashSet底层是HashMap、LinkedHashSet底层是LinkedHashMap、TreeSet底层是TreeMap</p><h3 id="_4、hashmap-和-hashtable-的区别-hashmap-和-hashset-区别-hashmap-和-treemap-区别" tabindex="-1"><a class="header-anchor" href="#_4、hashmap-和-hashtable-的区别-hashmap-和-hashset-区别-hashmap-和-treemap-区别" aria-hidden="true">#</a> 4、HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区别？</h3><h4 id="_4-1-hashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#_4-1-hashmap-和-hashtable-的区别" aria-hidden="true">#</a> 4.1 HashMap 和 Hashtable 的区别？</h4><p>HashMap在调用无参构造时初始容量为0，会在第一次put时调用真正确定容量，初始容量为16，负载因子为0.75f，临界值为12，HashMap底层数据结果为数组+链表+红黑树，HashMap是线程不安全的集合，HashMap每次扩容为之前的2倍</p><p>Hashtable是线程安全的集合，其底层数据结构为数组+链表，其初始容量为11，负载因子为0.75f，每次扩容为之前的2n+1</p><h4 id="_4-2-hashmap-和-hashset-区别" tabindex="-1"><a class="header-anchor" href="#_4-2-hashmap-和-hashset-区别" aria-hidden="true">#</a> 4.2 HashMap 和 HashSet 区别？</h4><p>HashSet的底层就是HashMap，HashSet是使用HashMap的key作为值，其中value是一个final修饰的Object对象</p><h4 id="_4-3-hashmap-和-treemap-区别" tabindex="-1"><a class="header-anchor" href="#_4-3-hashmap-和-treemap-区别" aria-hidden="true">#</a> 4.3 HashMap 和 TreeMap 区别？</h4><p>主要是底层数据结构的不同，HashMap是数组+链表+红黑树，TreeMap底层是红黑树</p><p>HashMap使用范围会更广些，</p><p>TreeMap在有需要定制排序需求时会适合些</p><h3 id="_5、hashmap-的底层实现" tabindex="-1"><a class="header-anchor" href="#_5、hashmap-的底层实现" aria-hidden="true">#</a> 5、HashMap 的底层实现</h3><p>HashMap在JDK1.7时，底层数据结构是数组+链表，采用的是头插法，在超高并发下可能存在死链问题，而且还存在链表长度过长的问题。</p><p>JDK1.8时对HashMap的进行了较大的升级，解决了JDK1.7时存在的两个较大的问题，针对死链问题采用尾插法解决，而针对链表长度过长问题，采用了数组+链表+红黑树的数据结构来解决了，具体解决方法如下，当链表的长度大于8时，并且数组的长度达到64时，此时就会将链表转成红黑树，以提升其查询能力。此时的HashMap比较完善了，但是不能说明此时的HashMap就是线程安全的了，在并发环境下，还是会存在数据不一致问题。</p><h3 id="_6、hashmap-的长度为什么是2的幂次方" tabindex="-1"><a class="header-anchor" href="#_6、hashmap-的长度为什么是2的幂次方" aria-hidden="true">#</a> 6、HashMap 的长度为什么是2的幂次方</h3><p>TODO</p><h3 id="_7、concurrenthashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#_7、concurrenthashmap-和-hashtable-的区别" aria-hidden="true">#</a> 7、ConcurrentHashMap 和 Hashtable 的区别</h3><p>Hashtable是加了一个全表锁实现的，锁的粒度很大，已经不推荐使用了。</p><p>ConcurrentHashMap是新的线程安全的Map</p><p>ConcurrentHashMap在JDK1.7的实现方式是使用分段锁的机制实现的，锁的粒度比较低</p><p>ConcurrentHashMap在JDK1.8时实现方式已经改成了CAS+synchronized实现了，锁的粒度更低，性能更好</p><h3 id="_8、concurrenthashmap-线程安全的具体实现方式-底层具体实现" tabindex="-1"><a class="header-anchor" href="#_8、concurrenthashmap-线程安全的具体实现方式-底层具体实现" aria-hidden="true">#</a> 8、ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h3>',28);function f(k,x){const r=i("CodeTabs");return d(),c("div",null,[u,a("details",m,[_,l(r,{id:"19",data:[{id:"pnpm"},{id:"yarn"},{id:"npm"}],active:2,"tab-id":"shell"},{title0:s(({value:h,isActive:t})=>[e("pnpm")]),title1:s(({value:h,isActive:t})=>[e("yarn")]),title2:s(({value:h,isActive:t})=>[e("npm")]),tab0:s(({value:h,isActive:t})=>[b]),tab1:s(({value:h,isActive:t})=>[H]),tab2:s(({value:h,isActive:t})=>[M]),_:1})]),v])}const C=p(o,[["render",f],["__file","集合常用面试题.html.vue"]]);export{C as default};
