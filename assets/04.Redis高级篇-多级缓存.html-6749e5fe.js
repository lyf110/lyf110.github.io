const e=JSON.parse('{"key":"v-1baa9660","path":"/database/redis/heima2022/04.Redis%E9%AB%98%E7%BA%A7%E7%AF%87-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.html","title":"四、Redis-高级篇-多级缓存","lang":"zh-CN","frontmatter":{"title":"四、Redis-高级篇-多级缓存","date":"2023-04-02T10:38:46.000Z","order":4,"category":["数据库","Redis","分布式缓存","中间件"],"tag":["数据库","Redis","分布式缓存","中间件"],"author":{"name":"liu yang fang","link":"https://github.com/lyf110"},"description":"多级缓存 0.学习目标 1.什么是多级缓存 传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图： image-20210821075259137 存在下面的问题： •请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈 •Redis缓存失效时，会对数据库产生冲击 多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：","head":[["meta",{"property":"og:url","content":"https://github.com/lyf110/database/redis/heima2022/04.Redis%E9%AB%98%E7%BA%A7%E7%AF%87-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.html"}],["meta",{"property":"og:site_name","content":"lyf blog"}],["meta",{"property":"og:title","content":"四、Redis-高级篇-多级缓存"}],["meta",{"property":"og:description","content":"多级缓存 0.学习目标 1.什么是多级缓存 传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图： image-20210821075259137 存在下面的问题： •请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈 •Redis缓存失效时，会对数据库产生冲击 多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/lyf110/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"四、Redis-高级篇-多级缓存"}],["meta",{"property":"article:author","content":"liu yang fang"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"分布式缓存"}],["meta",{"property":"article:tag","content":"中间件"}],["meta",{"property":"article:published_time","content":"2023-04-02T10:38:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"四、Redis-高级篇-多级缓存\\",\\"image\\":[\\"https://github.com/lyf110/\\"],\\"datePublished\\":\\"2023-04-02T10:38:46.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"liu yang fang\\",\\"link\\":\\"https://github.com/lyf110\\"}]}"]]},"headers":[{"level":2,"title":"2.1.导入案例","slug":"_2-1-导入案例","link":"#_2-1-导入案例","children":[]},{"level":2,"title":"2.2.初识Caffeine","slug":"_2-2-初识caffeine","link":"#_2-2-初识caffeine","children":[]},{"level":2,"title":"2.3.实现JVM进程缓存","slug":"_2-3-实现jvm进程缓存","link":"#_2-3-实现jvm进程缓存","children":[{"level":3,"title":"2.3.1.需求","slug":"_2-3-1-需求","link":"#_2-3-1-需求","children":[]},{"level":3,"title":"2.3.2.实现","slug":"_2-3-2-实现","link":"#_2-3-2-实现","children":[]}]},{"level":2,"title":"3.1.初识Lua","slug":"_3-1-初识lua","link":"#_3-1-初识lua","children":[]},{"level":2,"title":"3.1.HelloWorld","slug":"_3-1-helloworld","link":"#_3-1-helloworld","children":[]},{"level":2,"title":"3.2.变量和循环","slug":"_3-2-变量和循环","link":"#_3-2-变量和循环","children":[{"level":3,"title":"3.2.1.Lua的数据类型","slug":"_3-2-1-lua的数据类型","link":"#_3-2-1-lua的数据类型","children":[]},{"level":3,"title":"3.2.2.声明变量","slug":"_3-2-2-声明变量","link":"#_3-2-2-声明变量","children":[]},{"level":3,"title":"3.2.3.循环","slug":"_3-2-3-循环","link":"#_3-2-3-循环","children":[]}]},{"level":2,"title":"3.3.条件控制、函数","slug":"_3-3-条件控制、函数","link":"#_3-3-条件控制、函数","children":[{"level":3,"title":"3.3.1.函数","slug":"_3-3-1-函数","link":"#_3-3-1-函数","children":[]},{"level":3,"title":"3.3.2.条件控制","slug":"_3-3-2-条件控制","link":"#_3-3-2-条件控制","children":[]},{"level":3,"title":"3.3.3.案例","slug":"_3-3-3-案例","link":"#_3-3-3-案例","children":[]}]},{"level":2,"title":"4.1.安装OpenResty","slug":"_4-1-安装openresty","link":"#_4-1-安装openresty","children":[]},{"level":2,"title":"4.2.OpenResty快速入门","slug":"_4-2-openresty快速入门","link":"#_4-2-openresty快速入门","children":[{"level":3,"title":"4.2.1.反向代理流程","slug":"_4-2-1-反向代理流程","link":"#_4-2-1-反向代理流程","children":[]},{"level":3,"title":"4.2.2.OpenResty监听请求","slug":"_4-2-2-openresty监听请求","link":"#_4-2-2-openresty监听请求","children":[]},{"level":3,"title":"4.2.3.编写item.lua","slug":"_4-2-3-编写item-lua","link":"#_4-2-3-编写item-lua","children":[]}]},{"level":2,"title":"4.3.请求参数处理","slug":"_4-3-请求参数处理","link":"#_4-3-请求参数处理","children":[{"level":3,"title":"4.3.1.获取参数的API","slug":"_4-3-1-获取参数的api","link":"#_4-3-1-获取参数的api","children":[]},{"level":3,"title":"4.3.2.获取参数并返回","slug":"_4-3-2-获取参数并返回","link":"#_4-3-2-获取参数并返回","children":[]}]},{"level":2,"title":"4.4.查询Tomcat","slug":"_4-4-查询tomcat","link":"#_4-4-查询tomcat","children":[{"level":3,"title":"4.4.1.发送http请求的API","slug":"_4-4-1-发送http请求的api","link":"#_4-4-1-发送http请求的api","children":[]},{"level":3,"title":"4.4.2.封装http工具","slug":"_4-4-2-封装http工具","link":"#_4-4-2-封装http工具","children":[]},{"level":3,"title":"4.4.3.CJSON工具类","slug":"_4-4-3-cjson工具类","link":"#_4-4-3-cjson工具类","children":[]},{"level":3,"title":"4.4.4.实现Tomcat查询","slug":"_4-4-4-实现tomcat查询","link":"#_4-4-4-实现tomcat查询","children":[]},{"level":3,"title":"4.4.5.基于ID负载均衡","slug":"_4-4-5-基于id负载均衡","link":"#_4-4-5-基于id负载均衡","children":[]}]},{"level":2,"title":"4.5.Redis缓存预热","slug":"_4-5-redis缓存预热","link":"#_4-5-redis缓存预热","children":[]},{"level":2,"title":"4.6.查询Redis缓存","slug":"_4-6-查询redis缓存","link":"#_4-6-查询redis缓存","children":[{"level":3,"title":"4.6.1.封装Redis工具","slug":"_4-6-1-封装redis工具","link":"#_4-6-1-封装redis工具","children":[]},{"level":3,"title":"4.6.2.实现Redis查询","slug":"_4-6-2-实现redis查询","link":"#_4-6-2-实现redis查询","children":[]}]},{"level":2,"title":"4.7.Nginx本地缓存","slug":"_4-7-nginx本地缓存","link":"#_4-7-nginx本地缓存","children":[{"level":3,"title":"4.7.1.本地缓存API","slug":"_4-7-1-本地缓存api","link":"#_4-7-1-本地缓存api","children":[]},{"level":3,"title":"4.7.2.实现本地缓存查询","slug":"_4-7-2-实现本地缓存查询","link":"#_4-7-2-实现本地缓存查询","children":[]}]},{"level":2,"title":"5.1.数据同步策略","slug":"_5-1-数据同步策略","link":"#_5-1-数据同步策略","children":[]},{"level":2,"title":"5.2.安装Canal","slug":"_5-2-安装canal","link":"#_5-2-安装canal","children":[{"level":3,"title":"5.2.1.认识Canal","slug":"_5-2-1-认识canal","link":"#_5-2-1-认识canal","children":[]},{"level":3,"title":"5.2.2.安装Canal","slug":"_5-2-2-安装canal","link":"#_5-2-2-安装canal","children":[]}]},{"level":2,"title":"5.3.监听Canal","slug":"_5-3-监听canal","link":"#_5-3-监听canal","children":[{"level":3,"title":"5.3.1.引入依赖：","slug":"_5-3-1-引入依赖","link":"#_5-3-1-引入依赖","children":[]},{"level":3,"title":"5.3.2.编写配置：","slug":"_5-3-2-编写配置","link":"#_5-3-2-编写配置","children":[]},{"level":3,"title":"5.3.3.修改Item实体类","slug":"_5-3-3-修改item实体类","link":"#_5-3-3-修改item实体类","children":[]},{"level":3,"title":"5.3.4.编写监听器","slug":"_5-3-4-编写监听器","link":"#_5-3-4-编写监听器","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":28.88,"words":8665},"filePathRelative":"database/redis/heima2022/04.Redis高级篇-多级缓存.md","localizedDate":"2023年4月2日","excerpt":"<h1> 多级缓存</h1>\\n<h1> 0.学习目标</h1>\\n<h1> 1.什么是多级缓存</h1>\\n<p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：</p>\\n<figure><figcaption>image-20210821075259137</figcaption></figure>\\n<p>存在下面的问题：</p>\\n<p>•请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</p>\\n<p>•Redis缓存失效时，会对数据库产生冲击</p>\\n<p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p>","copyright":{"author":"liu yang fang","license":"Apache License 2.0"},"autoDesc":true}');export{e as data};
