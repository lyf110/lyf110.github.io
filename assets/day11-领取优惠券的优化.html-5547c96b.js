const l=JSON.parse('{"key":"v-559f4941","path":"/project/tjxt/notes/day11-%E9%A2%86%E5%8F%96%E4%BC%98%E6%83%A0%E5%88%B8%E7%9A%84%E4%BC%98%E5%8C%96.html","title":"day11-领取优惠券的优化","lang":"zh-CN","frontmatter":{"title":"day11-领取优惠券的优化","date":"2023-07-15T19:20:23.000Z","order":11,"category":["项目","天机学堂"],"tag":["项目","天机学堂"],"author":{"name":"liuyangfang","link":"https://github.com/lyf110"},"description":"day11-领取优惠券的优化 在昨天的学习中，我们已经实现了领取优惠券的功能，并且解决了多线程下的券超发的并发安全问题。不过，之前我们考虑的是单机模式下的多线程问题，解决的思路是基于Synchronized锁。 但是在集群模式下，传统的并发锁是否依然有效呢？因锁带来的性能损耗又该如何解决呢？今天我们就来思考并解决这些问题。 学习目标： 理解分布式锁的原理和使用场景 掌握Redisson的分布式锁用法 能实现基于注解的分布式锁 能利用MQ解决高并发写性能问题 了解Redis的LUA脚本的作用","head":[["meta",{"property":"og:url","content":"https://github.com/lyf110/project/tjxt/notes/day11-%E9%A2%86%E5%8F%96%E4%BC%98%E6%83%A0%E5%88%B8%E7%9A%84%E4%BC%98%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"lyf blog"}],["meta",{"property":"og:title","content":"day11-领取优惠券的优化"}],["meta",{"property":"og:description","content":"day11-领取优惠券的优化 在昨天的学习中，我们已经实现了领取优惠券的功能，并且解决了多线程下的券超发的并发安全问题。不过，之前我们考虑的是单机模式下的多线程问题，解决的思路是基于Synchronized锁。 但是在集群模式下，传统的并发锁是否依然有效呢？因锁带来的性能损耗又该如何解决呢？今天我们就来思考并解决这些问题。 学习目标： 理解分布式锁的原理和使用场景 掌握Redisson的分布式锁用法 能实现基于注解的分布式锁 能利用MQ解决高并发写性能问题 了解Redis的LUA脚本的作用"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/lyf110/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"day11-领取优惠券的优化"}],["meta",{"property":"article:author","content":"liuyangfang"}],["meta",{"property":"article:tag","content":"项目"}],["meta",{"property":"article:tag","content":"天机学堂"}],["meta",{"property":"article:published_time","content":"2023-07-15T19:20:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"day11-领取优惠券的优化\\",\\"image\\":[\\"https://github.com/lyf110/\\"],\\"datePublished\\":\\"2023-07-15T19:20:23.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"liuyangfang\\",\\"link\\":\\"https://github.com/lyf110\\"}]}"]]},"headers":[{"level":2,"title":"1.1.集群下的锁失效问题","slug":"_1-1-集群下的锁失效问题","link":"#_1-1-集群下的锁失效问题","children":[]},{"level":2,"title":"1.2.简单分布式锁","slug":"_1-2-简单分布式锁","link":"#_1-2-简单分布式锁","children":[{"level":3,"title":"1.2.1.基本原理","slug":"_1-2-1-基本原理","link":"#_1-2-1-基本原理","children":[]},{"level":3,"title":"1.2.2.代码实现","slug":"_1-2-2-代码实现","link":"#_1-2-2-代码实现","children":[]},{"level":3,"title":"1.2.3.改造业务代码","slug":"_1-2-3-改造业务代码","link":"#_1-2-3-改造业务代码","children":[]}]},{"level":2,"title":"1.3.分布式锁的问题","slug":"_1-3-分布式锁的问题","link":"#_1-3-分布式锁的问题","children":[{"level":3,"title":"1.3.1.锁误删问题","slug":"_1-3-1-锁误删问题","link":"#_1-3-1-锁误删问题","children":[]},{"level":3,"title":"1.3.2.超时释放问题","slug":"_1-3-2-超时释放问题","link":"#_1-3-2-超时释放问题","children":[]},{"level":3,"title":"1.3.3.其它问题","slug":"_1-3-3-其它问题","link":"#_1-3-3-其它问题","children":[]}]},{"level":2,"title":"1.4.Redisson","slug":"_1-4-redisson","link":"#_1-4-redisson","children":[{"level":3,"title":"1.4.1.介绍","slug":"_1-4-1-介绍","link":"#_1-4-1-介绍","children":[]},{"level":3,"title":"1.4.2.快速入门","slug":"_1-4-2-快速入门","link":"#_1-4-2-快速入门","children":[]},{"level":3,"title":"1.4.3.项目集成","slug":"_1-4-3-项目集成","link":"#_1-4-3-项目集成","children":[]}]},{"level":2,"title":"1.5.通用分布式锁组件","slug":"_1-5-通用分布式锁组件","link":"#_1-5-通用分布式锁组件","children":[{"level":3,"title":"1.5.1.实现思路分析","slug":"_1-5-1-实现思路分析","link":"#_1-5-1-实现思路分析","children":[]},{"level":3,"title":"1.5.2.定义注解","slug":"_1-5-2-定义注解","link":"#_1-5-2-定义注解","children":[]},{"level":3,"title":"1.5.3.定义切面","slug":"_1-5-3-定义切面","link":"#_1-5-3-定义切面","children":[]},{"level":3,"title":"1.5.4.使用锁","slug":"_1-5-4-使用锁","link":"#_1-5-4-使用锁","children":[]},{"level":3,"title":"1.5.5.工厂模式切换锁类型","slug":"_1-5-5-工厂模式切换锁类型","link":"#_1-5-5-工厂模式切换锁类型","children":[]},{"level":3,"title":"1.5.6.锁失败策略","slug":"_1-5-6-锁失败策略","link":"#_1-5-6-锁失败策略","children":[]},{"level":3,"title":"1.5.7.基于SPEL的动态锁名","slug":"_1-5-7-基于spel的动态锁名","link":"#_1-5-7-基于spel的动态锁名","children":[]}]},{"level":2,"title":"2.1.优化思路分析","slug":"_2-1-优化思路分析","link":"#_2-1-优化思路分析","children":[]},{"level":2,"title":"2.2.优惠券缓存","slug":"_2-2-优惠券缓存","link":"#_2-2-优惠券缓存","children":[{"level":3,"title":"2.2.1.缓存数据结构","slug":"_2-2-1-缓存数据结构","link":"#_2-2-1-缓存数据结构","children":[]},{"level":3,"title":"2.2.2.缓存KEY前缀","slug":"_2-2-2-缓存key前缀","link":"#_2-2-2-缓存key前缀","children":[]},{"level":3,"title":"2.2.3.添加缓存","slug":"_2-2-3-添加缓存","link":"#_2-2-3-添加缓存","children":[]},{"level":3,"title":"2.2.4.移除缓存","slug":"_2-2-4-移除缓存","link":"#_2-2-4-移除缓存","children":[]}]},{"level":2,"title":"2.4.异步领券","slug":"_2-4-异步领券","link":"#_2-4-异步领券","children":[{"level":3,"title":"2.4.1.定义MQ消息规范","slug":"_2-4-1-定义mq消息规范","link":"#_2-4-1-定义mq消息规范","children":[]},{"level":3,"title":"2.4.2.基于Redis的领取资格校验","slug":"_2-4-2-基于redis的领取资格校验","link":"#_2-4-2-基于redis的领取资格校验","children":[]},{"level":3,"title":"2.4.3.监听MQ并领券","slug":"_2-4-3-监听mq并领券","link":"#_2-4-3-监听mq并领券","children":[]}]},{"level":2,"title":"3.1.异步的兑换码领券","slug":"_3-1-异步的兑换码领券","link":"#_3-1-异步的兑换码领券","children":[{"level":3,"title":"3.1.1.缓存兑换码","slug":"_3-1-1-缓存兑换码","link":"#_3-1-1-缓存兑换码","children":[]},{"level":3,"title":"3.1.2.改造领券功能","slug":"_3-1-2-改造领券功能","link":"#_3-1-2-改造领券功能","children":[]}]},{"level":2,"title":"3.2.基于LUA脚本的异步领券","slug":"_3-2-基于lua脚本的异步领券","link":"#_3-2-基于lua脚本的异步领券","children":[{"level":3,"title":"3.2.1.思路分析","slug":"_3-2-1-思路分析","link":"#_3-2-1-思路分析","children":[]},{"level":3,"title":"3.2.2.LUA语法","slug":"_3-2-2-lua语法","link":"#_3-2-2-lua语法","children":[]},{"level":3,"title":"3.2.3.Redis的LUA脚本","slug":"_3-2-3-redis的lua脚本","link":"#_3-2-3-redis的lua脚本","children":[]},{"level":3,"title":"3.2.4.SpringDataRedis调用LUA脚本的API","slug":"_3-2-4-springdataredis调用lua脚本的api","link":"#_3-2-4-springdataredis调用lua脚本的api","children":[]},{"level":3,"title":"3.3.5.领券脚本","slug":"_3-3-5-领券脚本","link":"#_3-3-5-领券脚本","children":[]},{"level":3,"title":"3.3.6.改造业务","slug":"_3-3-6-改造业务","link":"#_3-3-6-改造业务","children":[]}]},{"level":2,"title":"4.1.超发问题","slug":"_4-1-超发问题","link":"#_4-1-超发问题","children":[]},{"level":2,"title":"4.2.锁实现的问题","slug":"_4-2-锁实现的问题","link":"#_4-2-锁实现的问题","children":[]},{"level":2,"title":"4.3.性能问题","slug":"_4-3-性能问题","link":"#_4-3-性能问题","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":40.95,"words":12284},"filePathRelative":"project/tjxt/notes/day11-领取优惠券的优化.md","localizedDate":"2023年7月16日","excerpt":"<h1> day11-领取优惠券的优化</h1>\\n<p>在昨天的学习中，我们已经实现了领取优惠券的功能，并且解决了多线程下的券超发的并发安全问题。不过，之前我们考虑的是单机模式下的多线程问题，解决的思路是基于Synchronized锁。</p>\\n<p>但是在集群模式下，传统的并发锁是否依然有效呢？因锁带来的性能损耗又该如何解决呢？今天我们就来思考并解决这些问题。</p>\\n<p>学习目标：</p>\\n<ul>\\n<li>理解分布式锁的原理和使用场景</li>\\n<li>掌握Redisson的分布式锁用法</li>\\n<li>能实现基于注解的分布式锁</li>\\n<li>能利用MQ解决高并发写性能问题</li>\\n<li>了解Redis的LUA脚本的作用</li>\\n</ul>","copyright":{"author":"liu yang fang","license":"Apache License 2.0"},"autoDesc":true}');export{l as data};
