const n=JSON.parse('{"key":"v-c1561fa8","path":"/java/socket/netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81.html","title":"四、优化与源码","lang":"zh-CN","frontmatter":{"title":"四、优化与源码","date":"2023-04-03T14:56:23.000Z","order":4,"category":["中间件","网络编程","Socket","Netty","Channel","Buffer","NIO","BIO"],"tag":["中间件","网络编程","Socket","Netty","Channel","Buffer","NIO","BIO"],"author":{"name":"liuyangfang","link":"https://github.com/lyf110"},"description":"四. 优化与源码 1. 优化 1.1 扩展序列化算法 序列化，反序列化主要用在消息正文的转换上 序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]） 反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理 目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下 // 反序列化 byte[] body = new byte[bodyLength]; byteByf.readBytes(body); ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(body)); Message message = (Message) in.readObject(); message.setSequenceId(sequenceId); // 序列化 ByteArrayOutputStream out = new ByteArrayOutputStream(); new ObjectOutputStream(out).writeObject(message); byte[] bytes = out.toByteArray();","head":[["meta",{"property":"og:url","content":"https://github.com/lyf110/java/socket/netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81.html"}],["meta",{"property":"og:site_name","content":"lyf blog"}],["meta",{"property":"og:title","content":"四、优化与源码"}],["meta",{"property":"og:description","content":"四. 优化与源码 1. 优化 1.1 扩展序列化算法 序列化，反序列化主要用在消息正文的转换上 序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]） 反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理 目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下 // 反序列化 byte[] body = new byte[bodyLength]; byteByf.readBytes(body); ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(body)); Message message = (Message) in.readObject(); message.setSequenceId(sequenceId); // 序列化 ByteArrayOutputStream out = new ByteArrayOutputStream(); new ObjectOutputStream(out).writeObject(message); byte[] bytes = out.toByteArray();"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/lyf110/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"四、优化与源码"}],["meta",{"property":"article:author","content":"liuyangfang"}],["meta",{"property":"article:tag","content":"中间件"}],["meta",{"property":"article:tag","content":"网络编程"}],["meta",{"property":"article:tag","content":"Socket"}],["meta",{"property":"article:tag","content":"Netty"}],["meta",{"property":"article:tag","content":"Channel"}],["meta",{"property":"article:tag","content":"Buffer"}],["meta",{"property":"article:tag","content":"NIO"}],["meta",{"property":"article:tag","content":"BIO"}],["meta",{"property":"article:published_time","content":"2023-04-03T14:56:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"四、优化与源码\\",\\"image\\":[\\"https://github.com/lyf110/\\"],\\"datePublished\\":\\"2023-04-03T14:56:23.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"liuyangfang\\",\\"link\\":\\"https://github.com/lyf110\\"}]}"]]},"headers":[{"level":2,"title":"1. 优化","slug":"_1-优化","link":"#_1-优化","children":[{"level":3,"title":"1.1 扩展序列化算法","slug":"_1-1-扩展序列化算法","link":"#_1-1-扩展序列化算法","children":[]},{"level":3,"title":"1.2 参数调优","slug":"_1-2-参数调优","link":"#_1-2-参数调优","children":[]},{"level":3,"title":"1.3 RPC 框架","slug":"_1-3-rpc-框架","link":"#_1-3-rpc-框架","children":[]}]},{"level":2,"title":"2. 源码分析","slug":"_2-源码分析","link":"#_2-源码分析","children":[{"level":3,"title":"2.1 启动剖析","slug":"_2-1-启动剖析","link":"#_2-1-启动剖析","children":[]},{"level":3,"title":"2.2 NioEventLoop 剖析","slug":"_2-2-nioeventloop-剖析","link":"#_2-2-nioeventloop-剖析","children":[]},{"level":3,"title":"2.3 accept 剖析","slug":"_2-3-accept-剖析","link":"#_2-3-accept-剖析","children":[]},{"level":3,"title":"2.4 read 剖析","slug":"_2-4-read-剖析","link":"#_2-4-read-剖析","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":21.99,"words":6598},"filePathRelative":"java/socket/netty/Netty04-优化与源码.md","localizedDate":"2023年4月3日","excerpt":"<h1> 四. 优化与源码</h1>\\n<h2> 1. 优化</h2>\\n<h3> 1.1 扩展序列化算法</h3>\\n<p>序列化，反序列化主要用在消息正文的转换上</p>\\n<ul>\\n<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>\\n<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>\\n</ul>\\n<p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token comment\\">// 反序列化</span>\\n<span class=\\"token keyword\\">byte</span><span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span> body <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token keyword\\">byte</span><span class=\\"token punctuation\\">[</span>bodyLength<span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">;</span>\\nbyteByf<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">readBytes</span><span class=\\"token punctuation\\">(</span>body<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token class-name\\">ObjectInputStream</span> in <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">ObjectInputStream</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">ByteArrayInputStream</span><span class=\\"token punctuation\\">(</span>body<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token class-name\\">Message</span> message <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">Message</span><span class=\\"token punctuation\\">)</span> in<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">readObject</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\nmessage<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">setSequenceId</span><span class=\\"token punctuation\\">(</span>sequenceId<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token comment\\">// 序列化</span>\\n<span class=\\"token class-name\\">ByteArrayOutputStream</span> out <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">ByteArrayOutputStream</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">ObjectOutputStream</span><span class=\\"token punctuation\\">(</span>out<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">writeObject</span><span class=\\"token punctuation\\">(</span>message<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token keyword\\">byte</span><span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span> bytes <span class=\\"token operator\\">=</span> out<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">toByteArray</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","copyright":{"author":"liu yang fang","license":"Apache License 2.0"},"autoDesc":true}');export{n as data};
