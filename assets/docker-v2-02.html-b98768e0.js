import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as c,c as t,a as s,b as n,d as i,e as a}from"./app-5f6064b2.js";const d="/assets/1559982883731-d1a0a154.png",o="/assets/1559984959131-d23710a2.png",p="/assets/1559985528414-a9e7292b.png",v="/assets/1560066592114-88471361.png",u="/assets/1560066453876-4232cfb9.png",m="/assets/1560068187865-afa8d041.png",b="data:image/png;base64,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",k="/assets/1560068770396-883c27b2.png",g="/assets/1560068979804-0c72b77d.png",A="/assets/1560068988127-53bc1f69.png",h="/assets/1560069227325-95bde307.png",f="/assets/1560069254431-4f37ba8a.png",w="/assets/1560069267443-789391b5.png",y="/assets/1560075565234-d0e62193.png",D="/assets/1560075629895-51e3bac2.png",_="/assets/1560075901178-7d430930.png",x={},C=a(`<h1 id="docker-二" tabindex="-1"><a class="header-anchor" href="#docker-二" aria-hidden="true">#</a> docker（二）</h1><p>课程目标：</p><p>1、docker镜像制作</p><p>2、docker仓库</p><p>3、docker网络管理</p><p>4、搭建docker swarm集群</p><p>5、docker compose编排工具</p><p>6、docker的web可视化管理工具</p><h1 id="_1-docker镜像制作" tabindex="-1"><a class="header-anchor" href="#_1-docker镜像制作" aria-hidden="true">#</a> 1 docker镜像制作</h1><p>docker官方和个人发布的镜像由于版本等各种原因，漏洞较多，已统计Docker Hub超过30%的官方镜像包含高危漏洞。此外，由于网络等原因也会造成docker pull下载镜像的速度很慢。基于这种情况，我们可以手动定制docker系统镜像。构建镜像的方式有两种：</p><ul><li>使用docker commit命令</li><li>使用docker build和Dockerfile文件</li></ul><h2 id="_1-1-docker-commit" tabindex="-1"><a class="header-anchor" href="#_1-1-docker-commit" aria-hidden="true">#</a> 1.1 docker commit</h2><h3 id="_1-1-1-制作步骤" tabindex="-1"><a class="header-anchor" href="#_1-1-1-制作步骤" aria-hidden="true">#</a> 1.1.1 制作步骤</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> commit：提交一个正在运行的容器为一个新的镜像

本例：制作一个tomcat镜像，制作步骤：
<span class="token number">1</span>、拉取一个基础镜像（其始就是OS）
<span class="token function">docker</span> pull centos

<span class="token number">2</span>、创建一个交互式容器
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>mycentos centos:latest

<span class="token number">3</span>、软件上传：将宿主机Tomact、jdk上传到容器中
<span class="token function">docker</span> <span class="token function">cp</span> apache-tomcat-7.0.47.tar.gz mycentos:/root/
<span class="token function">docker</span> <span class="token function">cp</span> jdk-8u161-linux-x64.tar.gz mycentos:/root/

<span class="token number">4</span>、在容器中安装jdk  （yum <span class="token function">install</span> java-1.7.0-openjdk）
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> jdk-8u161-linux-x64.tar.gz <span class="token parameter variable">-C</span> /usr/local/
编辑/etc/profile文件，添加如下内容：
<span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/local/jdk1.8.0_161
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">$JAVA_HOME</span>/bin:<span class="token environment constant">$PATH</span>

<span class="token number">5</span>、在容器中安装tomcat
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> apache-tomcat-7.0.47.tar.gz <span class="token parameter variable">-C</span> /usr/local/
编辑tomcat/bin/setclsspath.sh文件，添加如下内容：
<span class="token builtin class-name">export</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/local/jdk1.8.0_161
<span class="token builtin class-name">export</span> <span class="token assign-left variable">JRE_HOME</span><span class="token operator">=</span>/usr/local/jdk1.8.0_161/jre

<span class="token number">6</span>、将正在运行的容器提交为一个新的镜像
<span class="token function">docker</span> commit mycentos mytomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-1-2-端口映射" tabindex="-1"><a class="header-anchor" href="#_1-1-2-端口映射" aria-hidden="true">#</a> 1.1.2 端口映射</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>t1 <span class="token parameter variable">-p</span> <span class="token number">8888</span>:8080 mytomcat /bin/bash
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> t1 /usr/local/apache-tomcat-7.0.47/bin/startup.sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,16),E={href:"http://ip",target:"_blank",rel:"noopener noreferrer"},I=a('<figure><img src="'+d+`" alt="1559982883731" tabindex="0" loading="lazy"><figcaption>1559982883731</figcaption></figure><h3 id="_1-1-3-目录挂载" tabindex="-1"><a class="header-anchor" href="#_1-1-3-目录挂载" aria-hidden="true">#</a> 1.1.3 目录挂载</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>、启动容器t1
<span class="token function">docker</span> run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--name</span> t1 mytomcat

<span class="token number">2</span>、完成目录映射
<span class="token function">docker</span> <span class="token function">cp</span> t1:/usr/local/tomcat7/webapps /opt/
<span class="token function">docker</span> <span class="token function">cp</span> t1:/uer/local/tomcat7/conf /opt/

<span class="token number">3</span>、停止容器t1并删除
<span class="token function">docker</span> stop t1
<span class="token function">docker</span> <span class="token function">rm</span> t1

<span class="token number">4</span>、启动一个新容器并且做目录挂载
<span class="token function">docker</span> run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--name</span> t1 <span class="token parameter variable">-p</span> <span class="token number">9999</span>:8080 <span class="token parameter variable">-v</span> /opt/webapps/:/usr/local/tomcat7/webapps <span class="token parameter variable">-v</span> /opt/conf/:/usr/local/tomcat7/conf mytomcat

<span class="token number">3</span>、启动容器中的tomcat
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> t1 /usr/local/tomcat7/bin/startup.sh

<span class="token number">4</span>、通过浏览器访问

<span class="token number">5</span>、设置宿主机/opt/webapps/下文件时，容器自动修改
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果如下：</p><figure><img src="`+o+`" alt="1559984959131" tabindex="0" loading="lazy"><figcaption>1559984959131</figcaption></figure><h3 id="_1-1-4-容器-镜像打包" tabindex="-1"><a class="header-anchor" href="#_1-1-4-容器-镜像打包" aria-hidden="true">#</a> 1.1.4 容器/镜像打包</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>镜像打包：
1、镜像打包：
docker save -o /root/tomcat7.tar mytomcat
2、将打包的镜像上传到其他服务器
scp tomcat7.tar 其他服务器ip:/root
3、导入镜像
docker load -i /root/tomcat7.tar

容器打包：
1、容器打包
docker export -o /root/t1.tar t1
2、导入容器
docker import t1.tar mytomcat:latest

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_1-2-docker-builder" tabindex="-1"><a class="header-anchor" href="#_1-2-docker-builder" aria-hidden="true">#</a> 1.2 docker builder</h2><p>Dockerfile使用基本的基于DSL语法的指令来构建一个Docker镜像，之后使用docker builder命令基于该Dockerfile中的指令构建一个新的镜像。</p><h3 id="_1-2-1-dsl语法" tabindex="-1"><a class="header-anchor" href="#_1-2-1-dsl语法" aria-hidden="true">#</a> 1.2.1 DSL语法</h3><figure><img src="`+p+`" alt="1559985528414" tabindex="0" loading="lazy"><figcaption>1559985528414</figcaption></figure><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>DSL语法：

1）FROM（指定基础image）
构建指令，必须指定且需要在Dockerfile其他指令的前面。后续的指令都依赖于该指令指定的image。FROM指令指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。
<span class="token key attr-name">FROM命令告诉docker我们构建的镜像是以哪个(发行版)镜像为基础的。第一条指令必须是FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个</span> <span class="token value attr-value">FROM 指令。</span>
 
该指令有两种格式：
<span class="token key attr-name">FROM</span> <span class="token value attr-value">&lt;image&gt; </span>
指定基础image为该image的最后修改的版本。或者：
 
<span class="token key attr-name">FROM</span> <span class="token value attr-value">&lt;image&gt;:&lt;tag&gt; </span>
指定基础image为该image的一个tag版本。
 
<span class="token key attr-name">RUN后面接要执行的命令，比如，我们想在镜像中安装vim，只需在Dockfile中写入</span> <span class="token value attr-value">RUN yum install -y vim</span>
 
2）MAINTAINER（用来指定镜像创建者信息）
<span class="token key attr-name">构建指令，用于将image的制作者相关的信息写入到image中。当我们对该image执行docker</span> <span class="token value attr-value">inspect命令时，输出中有相应的字段记录该信息。</span>
 
格式：
<span class="token key attr-name">MAINTAINER</span> <span class="token value attr-value">&lt;name&gt; </span>
 
3）RUN（安装软件用）
构建指令，RUN可以运行任何被基础image支持的命令。如基础image选择了ubuntu，那么软件管理部分只能使用ubuntu的命令。
 
该指令有两种格式：
<span class="token key attr-name">RUN</span> <span class="token value attr-value">&lt;command&gt;  </span>
<span class="token key attr-name">RUN</span> <span class="token value attr-value">[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ... ] </span>
 
4）CMD（设置container启动时执行的操作）
设置指令，用于container启动时指定的操作。该操作可以是执行自定义脚本，也可以是执行系统命令。该指令只能在文件中存在一次，如果有多个，则只执行最后一条。
 
该指令有三种格式：
<span class="token key attr-name">CMD</span> <span class="token value attr-value">[&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span>
<span class="token key attr-name">CMD</span> <span class="token value attr-value">command param1 param2</span>
 
当Dockerfile指定了ENTRYPOINT，那么使用下面的格式：
<span class="token key attr-name">CMD</span> <span class="token value attr-value">[&quot;param1&quot;,&quot;param2&quot;]</span>
 
其中：
ENTRYPOINT指定的是一个可执行的脚本或者程序的路径，该指定的脚本或者程序将会以param1和param2作为参数执行。
所以如果CMD指令使用上面的形式，那么Dockerfile中必须要有配套的ENTRYPOINT。
 
5）ENTRYPOINT（设置container启动时执行的操作）
设置指令，指定容器启动时执行的命令，可以多次设置，但是只有最后一个有效。
 
<span class="token key attr-name">两种格式</span><span class="token punctuation">:</span>
<span class="token key attr-name">ENTRYPOINT</span> <span class="token value attr-value">[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span>
<span class="token key attr-name">ENTRYPOINT</span> <span class="token value attr-value">command param1 param2</span>
 
该指令的使用分为两种情况，一种是独自使用，另一种和CMD指令配合使用。
当独自使用时，如果你还使用了CMD命令且CMD是一个完整的可执行的命令，那么CMD指令和ENTRYPOINT会互相覆盖，只有最后一个CMD或者ENTRYPOINT有效。
 
<span class="token comment"># CMD指令将不会被执行，只有ENTRYPOINT指令被执行 </span>
<span class="token key attr-name">CMD</span> <span class="token value attr-value">echo “Hello, World!” </span>
<span class="token key attr-name">ENTRYPOINT</span> <span class="token value attr-value">ls -l </span>
 
另一种用法和CMD指令配合使用来指定ENTRYPOINT的默认参数，这时CMD指令不是一个完整的可执行命令，仅仅是参数部分；
ENTRYPOINT指令只能使用JSON方式指定执行命令，而不能指定参数。
 
<span class="token key attr-name">FROM</span> <span class="token value attr-value">ubuntu </span>
<span class="token key attr-name">CMD</span> <span class="token value attr-value">[&quot;-l&quot;] </span>
<span class="token key attr-name">ENTRYPOINT</span> <span class="token value attr-value">[&quot;/usr/bin/ls&quot;] </span>
 
6）USER（设置container容器的用户）
设置指令，设置启动容器的用户，默认是root用户。
 
<span class="token comment"># 指定memcached的运行用户 </span>
<span class="token key attr-name">ENTRYPOINT</span> <span class="token value attr-value">[&quot;memcached&quot;] </span>
<span class="token key attr-name">USER</span> <span class="token value attr-value">daemon </span>
或者
<span class="token key attr-name">ENTRYPOINT</span> <span class="token value attr-value">[&quot;memcached&quot;, &quot;-u&quot;, &quot;daemon&quot;] </span>
 
7）EXPOSE（指定容器需要映射到宿主机器的端口）
设置指令，该指令会将容器中的端口映射成宿主机器中的某个端口。当你需要访问容器的时候，可以不是用容器的IP地址而是使用宿主机器的IP地址和映射后的端口。
要完成整个操作需要两个步骤，首先在Dockerfile使用EXPOSE设置需要映射的容器端口，然后在运行容器的时候指定-p选项加上EXPOSE设置的端口，这样EXPOSE设置的端口号会被随机映射成宿主机器中的一个端口号。
也可以指定需要映射到宿主机器的那个端口，这时要确保宿主机器上的端口号没有被使用。EXPOSE指令可以一次设置多个端口号，相应的运行容器的时候，可以配套的多次使用-p选项。
 
<span class="token key attr-name">格式</span><span class="token punctuation">:</span>
<span class="token key attr-name">EXPOSE</span> <span class="token value attr-value">&lt;port&gt; [&lt;port&gt;...] </span>
 
<span class="token comment"># 映射一个端口 </span>
<span class="token key attr-name">EXPOSE</span> <span class="token value attr-value">port1 </span>
<span class="token comment"># 相应的运行容器使用的命令 </span>
<span class="token key attr-name">docker</span> <span class="token value attr-value">run -p port1 image </span>
   
<span class="token comment"># 映射多个端口 </span>
<span class="token key attr-name">EXPOSE</span> <span class="token value attr-value">port1 port2 port3 </span>
<span class="token comment"># 相应的运行容器使用的命令 </span>
<span class="token key attr-name">docker</span> <span class="token value attr-value">run -p port1 -p port2 -p port3 image </span>
<span class="token comment"># 还可以指定需要映射到宿主机器上的某个端口号 </span>
<span class="token key attr-name">docker</span> <span class="token value attr-value">run -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image</span>
 
端口映射是docker比较重要的一个功能，原因在于我们每次运行容器的时候容器的IP地址不能指定而是在桥接网卡的地址范围内随机生成的。
宿主机器的IP地址是固定的，我们可以将容器的端口的映射到宿主机器上的一个端口，免去每次访问容器中的某个服务时都要查看容器的IP的地址。
<span class="token key attr-name">对于一个运行的容器，可以使用docker</span> <span class="token value attr-value">port加上容器中需要映射的端口和容器的ID来查看该端口号在宿主机器上的映射端口。</span>
 
8）ENV（用于设置环境变量）
主要用于设置容器运行时的环境变量
 
<span class="token key attr-name">格式</span><span class="token punctuation">:</span>
<span class="token key attr-name">ENV</span> <span class="token value attr-value">&lt;key&gt; &lt;value&gt; </span>
 
<span class="token key attr-name">设置了后，后续的RUN命令都可以使用，container启动后，可以通过docker</span> <span class="token value attr-value">inspect查看这个环境变量，也可以通过在docker run --env key=value时设置或修改环境变量。</span>
 
假如你安装了JAVA程序，需要设置JAVA_HOME，那么可以在Dockerfile中这样写：
<span class="token key attr-name">ENV</span> <span class="token value attr-value">JAVA_HOME /path/to/java/dirent</span>
 
9）ADD（从src复制文件到container的dest路径）
主要用于将宿主机中的文件添加到镜像中
构建指令，所有拷贝到container中的文件和文件夹权限为0755，uid和gid为0；如果是一个目录，那么会将该目录下的所有文件添加到container中，不包括目录；
如果文件是可识别的压缩格式，则docker会帮忙解压缩（注意压缩格式）；如果&lt;src&gt;是文件且&lt;dest&gt;中不使用斜杠结束，则会将&lt;dest&gt;视为文件，&lt;src&gt;的内容会写入&lt;dest&gt;；
如果&lt;src&gt;是文件且&lt;dest&gt;中使用斜杠结束，则会&lt;src&gt;文件拷贝到&lt;dest&gt;目录下。
 
<span class="token key attr-name">格式</span><span class="token punctuation">:</span>
<span class="token key attr-name">ADD</span> <span class="token value attr-value">&lt;src&gt; &lt;dest&gt; </span>
 
<span class="token key attr-name">&lt;src&gt;</span> <span class="token value attr-value">是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url;</span>
<span class="token key attr-name">&lt;dest&gt;</span> <span class="token value attr-value">是container中的绝对路径</span>
 
10）VOLUME（指定挂载点)）
设置指令，使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器使用。我们知道容器使用的是AUFS，
这种文件系统不能持久化数据，当容器关闭后，所有的更改都会丢失。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。
 
<span class="token key attr-name">格式</span><span class="token punctuation">:</span>
<span class="token key attr-name">VOLUME</span> <span class="token value attr-value">[&quot;&lt;mountpoint&gt;&quot;]</span>
 
例如：
<span class="token key attr-name">FROM</span> <span class="token value attr-value">base </span>
<span class="token key attr-name">VOLUME</span> <span class="token value attr-value">[&quot;/tmp/data&quot;]</span>
 
运行通过该Dockerfile生成image的容器，/tmp/data目录中的数据在容器关闭后，里面的数据还存在。
例如另一个容器也有持久化数据的需求，且想使用上面容器共享的/tmp/data目录，那么可以运行下面的命令启动一个容器：
<span class="token key attr-name">docker</span> <span class="token value attr-value">run -t -i -rm -volumes-from container1 image2 bash</span>
 
其中：container1为第一个容器的ID，image2为第二个容器运行image的名字。
 
11）WORKDIR（切换目录）
设置指令，可以多次切换(相当于cd命令)，对RUN,CMD,ENTRYPOINT生效。
 
<span class="token key attr-name">格式</span><span class="token punctuation">:</span>
<span class="token key attr-name">WORKDIR</span> <span class="token value attr-value">/path/to/workdir </span>
 
<span class="token comment"># 在/p1/p2下执行vim a.txt </span>
<span class="token key attr-name">WORKDIR</span> <span class="token value attr-value">/p1 WORKDIR p2 RUN vim a.txt </span>
 
12）ONBUILD（在子镜像中执行）
 
格式：
<span class="token key attr-name">ONBUILD</span> <span class="token value attr-value">&lt;Dockerfile关键字&gt; </span>
 
<span class="token key attr-name">ONBUILD</span> <span class="token value attr-value">指定的命令在构建镜像时并不执行，而是在它的子镜像中执行。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-2-2-案例" tabindex="-1"><a class="header-anchor" href="#_1-2-2-案例" aria-hidden="true">#</a> 1.2.2 案例</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>通过dockerfile构建镜像步骤：
<span class="token number">1</span>、创建一个目录
<span class="token number">2</span>、在目录下创建Dockerfile文件以及其他文件
<span class="token number">3</span>、通过docker builder构建镜像
<span class="token number">4</span>、通过构建的镜像启动容器


栗子：
<span class="token number">1</span>、创建一个目录：/usr/local/rw_test
<span class="token number">2</span>、编辑Dockerfile文件,vim Dockerfile
<span class="token number">3</span>、编辑内容如下
<span class="token comment">#pull down centos image</span>
FROM docker.io/centos
MAINTAINER ruanwen onlien033_login@126.com

<span class="token comment">#install nginx</span>
RUN yum <span class="token function">install</span> <span class="token parameter variable">-y</span> pcre pcre-devel openssl openssl-devel gcc gcc+ <span class="token function">wget</span> <span class="token function">vim</span> net-tools
RUN <span class="token function">useradd</span> www <span class="token parameter variable">-M</span> <span class="token parameter variable">-s</span> /sbin/nologin
RUN <span class="token builtin class-name">cd</span> /usr/local/src <span class="token operator">&amp;&amp;</span> <span class="token function">wget</span> http://nginx.org/download/nginx-1.8.0.tar.gz <span class="token operator">&amp;&amp;</span> <span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> nginx-1.8.0.tar.gz
RUN <span class="token builtin class-name">cd</span> /usr/local/src/nginx-1.8.0 <span class="token operator">&amp;&amp;</span> ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/nginx <span class="token parameter variable">--user</span><span class="token operator">=</span>www <span class="token parameter variable">--group</span><span class="token operator">=</span>www --with-http_stub_status_module --with-http_ssl_module <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>

ENTRYPOINT /usr/local/nginx/sbin/nginx <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> <span class="token parameter variable">-f</span> /usr/local/nginx/logs/access.log

<span class="token number">4</span>、在rw_test目录下构建镜像：
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> rw_nginx <span class="token parameter variable">--rm</span><span class="token operator">=</span>true <span class="token builtin class-name">.</span>
<span class="token parameter variable">-t</span>    表示选择指定生成镜像的用户名，仓库名和tag
<span class="token parameter variable">--rm</span><span class="token operator">=</span>true    表示指定在生成镜像过程中删除中间产生的临时容器。
注意：上面构建命令中最后的.符号不要漏了，表示使用当前目录下的Dockerfile构建镜像

<span class="token number">5</span>、测试
<span class="token function">docker</span> run <span class="token parameter variable">-ti</span> <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> test_nginx <span class="token parameter variable">-p</span> <span class="token number">8899</span>:80 rw_nginx /bin/bash
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> test_nginx /bin/bash
通过浏览器访问：http://ip:8899
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_2-docker仓库" tabindex="-1"><a class="header-anchor" href="#_2-docker仓库" aria-hidden="true">#</a> 2 docker仓库</h1><p>Docker仓库（Repository）类似与代码仓库，是Docker集中存放镜像文件的地方。</p><h2 id="_2-1-docker-hub" tabindex="-1"><a class="header-anchor" href="#_2-1-docker-hub" aria-hidden="true">#</a> 2.1 docker hub</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>、打开https://hub.docker.com/
<span class="token number">2</span>、注册账号：略
<span class="token number">3</span>、创建仓库（Create Repository）：略
<span class="token number">4</span>、设置镜像标签
<span class="token function">docker</span> tag local-image:tagname new-repo:tagname（设置tag）
eg:docker tag hello-world:latest <span class="token number">108001509033</span>/test-hello-world:v1
<span class="token number">5</span>、登录docker hub
<span class="token function">docker</span> login<span class="token punctuation">(</span>回车，输入账号以及密码<span class="token punctuation">)</span>
<span class="token number">6</span>、推送镜像
<span class="token function">docker</span> push new-repo:tagname
eg：docker push <span class="token number">108001509033</span>/test-hello-world:v1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-2-阿里云" tabindex="-1"><a class="header-anchor" href="#_2-2-阿里云" aria-hidden="true">#</a> 2.2 阿里云</h2><p>略：参考官方文档。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>步骤：
<span class="token number">1</span>、创建阿里云账号
<span class="token number">2</span>、创建命名空间
<span class="token number">3</span>、创建镜像仓库
<span class="token number">4</span>、操作指南
$ <span class="token function">sudo</span> <span class="token function">docker</span> login <span class="token parameter variable">--username</span><span class="token operator">=</span><span class="token punctuation">[</span>账号名称<span class="token punctuation">]</span> registry.cn-hangzhou.aliyuncs.com
$ <span class="token function">sudo</span> <span class="token function">docker</span> tag <span class="token punctuation">[</span>ImageId<span class="token punctuation">]</span> registry.cn-hangzhou.aliyuncs.com/360buy/portal:<span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span>
$ <span class="token function">sudo</span> <span class="token function">docker</span> push registry.cn-hangzhou.aliyuncs.com/360buy/portal:<span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-3-搭建私有仓库" tabindex="-1"><a class="header-anchor" href="#_2-3-搭建私有仓库" aria-hidden="true">#</a> 2.3 搭建私有仓库</h2><h3 id="_2-3-1-构建私有仓库" tabindex="-1"><a class="header-anchor" href="#_2-3-1-构建私有仓库" aria-hidden="true">#</a> 2.3.1 构建私有仓库</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>、启动Docker Registry，使用Docker官方提供的Registry镜像就可以搭建本地私有镜像仓库，具体指令如下。
$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\\</span>
  <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 <span class="token punctuation">\\</span>
  <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token punctuation">\\</span>
  <span class="token parameter variable">--name</span> registry <span class="token punctuation">\\</span>
  <span class="token parameter variable">-v</span> /mnt/registry:/var/lib/registry <span class="token punctuation">\\</span>
  registry:2

指令参数说明：
-d：表示在后台运行该容器；
<span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000：表示将私有镜像仓库容器内部默认暴露的5000端口映射到宿主机的5000端口
<span class="token parameter variable">--restart</span><span class="token operator">=</span>always：表示容器启动后自动启动本地私有镜像仓库
<span class="token parameter variable">--name</span> registry：表示为生成的容器命名为registry
<span class="token parameter variable">-v</span> /mnt/registry:/var/lib/registry：表示将容器内的默认存储位置/var/lib/registry中的数据挂载到宿主机的/mnt/registry目录下，这样当容器销毁后，在容器中/var/lib/registry目录下的数据会自动备份到宿主机指定目录

小提示：
Docker Registry目前有v1和v2两个版本，v2版本并不是v1版本的简单升级，而是在很多功能上都有了改进和优化。v1版本使用的是Python开发的，而v2版本是用go语言开发的；v1版本本地镜像仓库容器中数据默认挂载点是/tmp/registry，而v2版本的本地镜像仓库容器中数据默认挂载点是/var/lib/registry

<span class="token number">2</span>、重命名镜像，之前推送镜像时，都是默认推送到远程镜像仓库，而本次是将指定镜像推送到本地私有镜像仓库。由于推送到本地私有镜像仓库的镜像名必须符合“仓库IP:端口号/repository”的形式，因此需要按照要求修改镜像名称，具体操作指令如下。
$ <span class="token function">docker</span> tag hello-world:latest localhost:5000/myhellodocker

<span class="token number">3</span>、推送镜像，本地私有镜像仓库搭建并启动完成，同时要推送的镜像也已经准备就绪后，就可以将指定镜像推送到本地私有镜像仓库了，具体操作指令如下
$ <span class="token function">docker</span> push localhost:5000/myhellodocker

<span class="token number">4</span>、查看本地仓库镜像
http://localhost:5000/v2/myhellodocker/tags/list  （注意：使用该地址时注意镜像名称）

由于做了目录挂载，因此可以在本地的该目录下查看：
/mnt/registry/docker/registry/v2/repositories

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-2-配置私有仓库认证" tabindex="-1"><a class="header-anchor" href="#_2-3-2-配置私有仓库认证" aria-hidden="true">#</a> 2.3.2 配置私有仓库认证</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>一、配置私有仓库认证
<span class="token number">1</span>、查看Docker Registry私有仓库搭建所在服务器地址：ifconfig
例如：服务器地址为：192.168.200.141

<span class="token number">2</span>、生成自签名证书（在home目录下执行上述指令后）
要确保Docker Registry本地镜像仓库的安全性，还需要一个安全认证证书，来保证其他Docker机器不能随意访问该机器上的Docker Registry本地镜像仓库，所以需要在搭建Docker Registry本地镜像仓库的Docker主机上先生成自签名证书（如果已购买证书就无需生成），具体操作指令如下。
$ <span class="token function">mkdir</span> registry <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> registry <span class="token operator">&amp;&amp;</span> <span class="token function">mkdir</span> certs <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> certs
$ openssl req <span class="token parameter variable">-x509</span> <span class="token parameter variable">-days</span> <span class="token number">3650</span> <span class="token parameter variable">-subj</span> <span class="token string">&#39;/CN=192.168.200.141:5000/&#39;</span> <span class="token punctuation">\\</span>
    <span class="token parameter variable">-nodes</span> <span class="token parameter variable">-newkey</span> rsa:2048 <span class="token parameter variable">-keyout</span> domain.key <span class="token parameter variable">-out</span> domain.crt

指令参数说明：
-x509：x509是一个自签发证书的格式
<span class="token parameter variable">-days</span> <span class="token number">3650</span>：表示证书有效期
<span class="token number">192.168</span>.197.141:5000：表示具体部署Docker Registry本地镜像仓库的地址和端口
rsa:2048：是证书算法长度
domain.key和domain.crt：就是生成的证书文件

<span class="token number">3</span>、生成用户名和密码
在Docker Registry本地镜像仓库所在的Docker主机上生成自签名证书后，为了确保Docker机器与该Docker Registry本地镜像仓库的交互，还需要生成一个连接认证的用户名和密码，使其他Docker用户只有通过用户名和密码登录后才允许连接到Docker Registry本地镜像仓库
$ <span class="token builtin class-name">cd</span> <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> <span class="token function">mkdir</span> auth
$ <span class="token function">docker</span> run <span class="token parameter variable">--entrypoint</span> htpasswd registry:2 <span class="token parameter variable">-Bbn</span> ruanwen <span class="token number">123456</span> <span class="token operator">&gt;</span> auth/htpasswd

<span class="token number">4</span>、启动Docker Registry本地镜像仓库服务（将之前创建的容器删除）
$ <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\\</span>
  <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 <span class="token punctuation">\\</span>
  <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token punctuation">\\</span>
  <span class="token parameter variable">--name</span> registry <span class="token punctuation">\\</span>
  <span class="token parameter variable">-v</span> /mnt/registry:/var/lib/registry <span class="token punctuation">\\</span>
  <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">\`</span><span class="token builtin class-name">pwd</span><span class="token variable">\`</span></span>/auth:/auth <span class="token punctuation">\\</span>
  <span class="token parameter variable">-e</span> <span class="token string">&quot;REGISTRY_AUTH=htpasswd&quot;</span> <span class="token punctuation">\\</span>
  <span class="token parameter variable">-e</span> <span class="token string">&quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot;</span> <span class="token punctuation">\\</span>
  <span class="token parameter variable">-e</span> <span class="token assign-left variable">REGISTRY_AUTH_HTPASSWD_PATH</span><span class="token operator">=</span>/auth/htpasswd <span class="token punctuation">\\</span>
  <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">\`</span><span class="token builtin class-name">pwd</span><span class="token variable">\`</span></span>/certs:/certs <span class="token punctuation">\\</span>
  <span class="token parameter variable">-e</span> <span class="token assign-left variable">REGISTRY_HTTP_TLS_CERTIFICATE</span><span class="token operator">=</span>/certs/domain.crt <span class="token punctuation">\\</span>
  <span class="token parameter variable">-e</span> <span class="token assign-left variable">REGISTRY_HTTP_TLS_KEY</span><span class="token operator">=</span>/certs/domain.key <span class="token punctuation">\\</span>
  registry:2

<span class="token number">5</span>、配置Docker Registry访问接口
完成Docker Registry本地镜像仓库服务启动后，还需要在搭建了Docker Registry本地镜像仓库所在的Docker主机上配置供其他Docker机器访问的接口，具体指令如下：
$ <span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /etc/docker/certs.d/192.168.200.141:5000
$ <span class="token function">sudo</span> <span class="token function">cp</span> certs/domain.crt /etc/docker/certs.d/192.168.200.141:5000

<span class="token number">6</span>、Docker Registry私有仓库使用登记
在Docker机器终端使用sudo <span class="token function">vim</span> /etc/docker/daemon.json命令编辑daemon.json文件，在该文件中添加如下内容
<span class="token punctuation">{</span><span class="token string">&quot;insecure-registries&quot;</span>:<span class="token punctuation">[</span><span class="token string">&quot;192.168.200.141:5000&quot;</span><span class="token punctuation">]</span><span class="token punctuation">}</span>

<span class="token number">7</span>、重启并加载docker配置文件
$ <span class="token function">sudo</span> /etc/init.d/docker restart

二、验证测试
<span class="token number">1</span>、装备镜像
$ <span class="token function">docker</span> tag hello-world:latest <span class="token number">192.168</span>.200.141:5000/myhelloworld
<span class="token number">2</span>、推送镜像
$ <span class="token function">docker</span> push <span class="token number">192.168</span>.200.141:5000/myhelloworld

送过程中出现错误，信息提示为：no basic auth credentials（即没有通过身份验证），所以无法进行推送，这也就说明身份验证的配置有效。要想成功推送，需要先登录成功后再推送

<span class="token number">3</span>、登录Docker Registry镜像仓库
$ <span class="token function">docker</span> login <span class="token number">192.168</span>.200.141:5000

<span class="token number">4</span>、再次推送
$ <span class="token function">docker</span> push <span class="token number">192.168</span>.200.139:5000/myhelloworld

<span class="token number">5</span>、结果验证
由于做了目录挂载，因此可以在本地的该目录下查看：
/mnt/registry/docker/registry/v2/repositories
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_3-docker网络管理" tabindex="-1"><a class="header-anchor" href="#_3-docker网络管理" aria-hidden="true">#</a> 3 docker网络管理</h1><h2 id="_3-1-默认网络" tabindex="-1"><a class="header-anchor" href="#_3-1-默认网络" aria-hidden="true">#</a> 3.1 默认网络</h2><p>1、查看docker网络：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Docker中默认的三种网络分别为bridge、host和none，其中名为bridge的网络就是默认的bridge驱动网络，也是容器创建时默认的网络管理方式，配置后可以与宿主机通信从而实现与互联网通信功能，而host和none属于无网络，容器添加到这两个网络时不能与外界网络通信。</p><p>这里介绍的三种网络bridge、host和none都是在非集群环境下Docker提供的默认网络，而在Docker Swarm集群环境下，除了这三种默认网络外，Docker还提供了docker_gwbridge和ingress两种默认网络。</p><figure><img src="`+v+`" alt="1560066592114" tabindex="0" loading="lazy"><figcaption>1560066592114</figcaption></figure><p>2、查看容器使用的网络情况：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network inspect bridge
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+u+`" alt="1560066453876" tabindex="0" loading="lazy"><figcaption>1560066453876</figcaption></figure><h2 id="_3-2-自定义网络" tabindex="-1"><a class="header-anchor" href="#_3-2-自定义网络" aria-hidden="true">#</a> 3.2 自定义网络</h2><p>虽然Docker提供的默认网络的使用比较简单，但是为了保证各容器中应用的安全性，在实际开发中更推荐使用自定义的网络进行容器管理。在Docker中，可以自定义bridge网络、overlay网络，也可以创建network plugin（网络插件）或者远程网络以实现容器网络的完全定制和控制。</p><h3 id="_3-2-1-网络类型" tabindex="-1"><a class="header-anchor" href="#_3-2-1-网络类型" aria-hidden="true">#</a> 3.2.1 网络类型</h3><ul><li><p><strong>Bridge networks</strong>（桥接网络）：</p><p>为了保证容器的安全性，我们可以使用基于bridge的驱动创建新的bridge网络，这种基于bridge驱动的自定义网络可以较好的实现容器隔离。需要说明的是，这种用户自定义的基于bridge驱动的网络对于单主机的小型网络环境管理是一个不错的选择，但是对于大型的网络环境管理（如集群）就需要考虑使用自定义overlay集群网络。</p></li><li><p><strong>Overlay network in swarm mode</strong>（Swarm集群中的覆盖网络）</p><p>在Docker Swarm集群环境下可以创建基于overlay驱动的自定义网络。为了保证安全性，Swarm集群使自定义的overlay网络只适用于需要服务的群集中的节点，而不会对外部其他服务或者Docker主机开放。</p></li><li><p><strong>Custom network plugins</strong>（定制网络插件）</p><p>如果前面几种自定义网络都无法满足需求时，就可以使用Docker提供的插件来自定义网络驱动插件。自定义网络插件会在Docker进程所在主机上作为另一个运行的进程。自定义网络驱动插件与其他插件遵循相同的限制和安装规则，所有插件都使用Docker提供的插件API，并且有一个包含安装、启动、停止和激活的生命周期。由于自定义网络插件使用较少，所以只需了解即可。</p></li></ul><h3 id="_3-2-2-自定义网络" tabindex="-1"><a class="header-anchor" href="#_3-2-2-自定义网络" aria-hidden="true">#</a> 3.2.2 自定义网络</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>、docker network create <span class="token parameter variable">--driver</span> bridge isolated_nw
创建一个基于bridge驱动的名称为isolated_nw的网络。其中--driver（可简写为-d）用于指定网络驱动类型，isolated_nw就是新创建的网络名称。需要说明的是，--driver bridge可以省略，省略时Docker会默认使用基于bridge驱动来创建新的网络。

<span class="token number">2</span>、docker run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>nwtest <span class="token parameter variable">--network</span><span class="token operator">=</span>isolated_nw busybox
会创建一个名为nwtest的容器，指令中的--network参数指定了该容器的网络连接为自定义的isolated_nw。通过docker inspect nwtest指令可以查看启动后的容器详情，来核查其网络管理方式.

<span class="token number">3</span>、docker network connect bridge nwtest
会为容器nwtest另添加一种默认的bridge网络管理方式。再次使用docker inspect nwtest指令查看该容器网络详情 

<span class="token number">4</span>、docker network disconnect isolated_nw nwtest
断开网络连接的指令与连接网络的指令类似，在使用时也需要指定网络名称和容器名称

<span class="token number">5</span>、docker network <span class="token function">rm</span> isolated_nw
移除名称为isolated_nw的自定义网络。当网络移除成功后，会返回网络名称。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-3-容器间的网络通信" tabindex="-1"><a class="header-anchor" href="#_3-3-容器间的网络通信" aria-hidden="true">#</a> 3.3 容器间的网络通信</h2><p>1、创建两个使用默认的bridge网络的容器</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c1 busybox
<span class="token function">docker</span> run <span class="token parameter variable">-itd</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c2 busybox
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、创建一个使用自定义的isolated_nw网络（需要预先创建）的容器</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--network</span><span class="token operator">=</span>isolated_nw <span class="token parameter variable">-itd</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c3 busybox
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3、为container2容器新增一个自定义的isolated_nw网络连接</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> network connect isolated_nw c2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>4、C1、C2、C3网络分配情况如下：</p><figure><img src="`+m+`" alt="1560068187865" tabindex="0" loading="lazy"><figcaption>1560068187865</figcaption></figure><p>5、测试容器间通信：分别登录C1、C2、C3容器，通过ping命令判断是否通信。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ping</span> <span class="token parameter variable">-w</span> <span class="token number">4</span> ip地址
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+b+`" alt="1560068419412" tabindex="0" loading="lazy"><figcaption>1560068419412</figcaption></figure><p>6、结论：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>不同容器之间想要相互通信必须在同一个网络环境下；使用默认bridge网络管理的容器可以使用容器IP进行通信，但无法使用容器名称进行通信；而使用自定义网络管理的容器则可以使用容器IP进行通信
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="_4-搭建docker-swarm集群" tabindex="-1"><a class="header-anchor" href="#_4-搭建docker-swarm集群" aria-hidden="true">#</a> 4 搭建docker swarm集群</h1><h2 id="_4-1-swarm介绍" tabindex="-1"><a class="header-anchor" href="#_4-1-swarm介绍" aria-hidden="true">#</a> 4.1 swarm介绍</h2><p>Swarm这个项目名称特别贴切。在Wiki的解释中，Swarm behavior是指动物的群集行为。比如我们常见的蜂群，鱼群，秋天往南飞的雁群都可以称作Swarm behavior。Swarm项目正是这样，通过把多个Docker Engine聚集在一起，形成一个大的docker-engine，对外提供容器的集群服务。同时这个集群对外提供Swarm API，用户可以像使用Docker Engine一样使用Docker集群。</p><figure><img src="`+k+'" alt="1560068770396" tabindex="0" loading="lazy"><figcaption>1560068770396</figcaption></figure><p>Swarm是Docker公司在2014年12月初发布的容器管理工具，和Swarm一起发布的Docker管理工具还有Machine以及Compose。Swarm是一套较为简单的工具，用以管理Docker集群，使得Docker集群暴露给用户时相当于一个虚拟的整体。Swarm将一群Docker宿主机变成一个单一的，虚拟的主机。Swarm使用标准的Docker API接口作为其前端访问入口，换言之，各种形式的Docker Client(docker client in Go, docker_py, docker等)均可以直接与Swarm通信。Swarm几乎全部用Go语言来完成开发，Swarm0.2版本增加了一个新的策略来调度集群中的容器，使得在可用的节点上传播它们，以及支持更多的Docker命令以及集群驱动。Swarm deamon只是一个调度器（Scheduler）加路由器(router)，Swarm自己不运行容器，它只是接受docker客户端发送过来的请求，调度适合的节点来运行容器，这意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，当Swarm重新恢复运行之后，它会收集重建集群信息。</p><p><strong>docker swarm特点：</strong></p><p>1) 对外以Docker API接口呈现，这样带来的好处是，如果现有系统使用Docker Engine，则可以平滑将Docker Engine切到Swarm上，无需改动现有系统。</p><p>2) Swarm对用户来说，之前使用Docker的经验可以继承过来。非常容易上手，学习成本和二次开发成本都比较低。同时Swarm本身专注于Docker集群管理，非常轻量，占用资源也非常少。简单说，就是插件化机制，Swarm中的各个模块都抽象出了API，可以根据自己一些特点进行定制实现。</p><p>3)  Swarm自身对Docker命令参数支持的比较完善，Swarm目前与Docker是同步发布的。Docker的新功能，都会第一时间在Swarm中体现。</p><h2 id="_4-2-docker-swarm架构" tabindex="-1"><a class="header-anchor" href="#_4-2-docker-swarm架构" aria-hidden="true">#</a> 4.2 docker swarm架构</h2><p>Swarm作为一个管理Docker集群的工具，首先需要将其部署起来，可以单独将Swarm部署于一个节点。另外，自然需要一个Docker集群，集群上每一个节点均安装有Docker。</p><p><img src="'+g+'" alt="1560068979804" loading="lazy"><img src="'+A+'" alt="1560068988127" loading="lazy"></p><p>相关术语：</p><ul><li><p>Swarm Manager：集群的管理工具，通过swarm manager管理多个节点。</p></li><li><p>Node：是已加入到swarm的Docker引擎的实例 。</p><ul><li><p>manager nodes：也就是管理节点 ，执行集群的管理功能，维护集群的状态，选举一个leader节点去执 行调度任务</p></li><li><p>worker nodes，也就是工作节点 ，接收和执行任务。参与容器集群负载调度，仅用于承载task</p><figure><img src="'+h+'" alt="1560069227325" tabindex="0" loading="lazy"><figcaption>1560069227325</figcaption></figure></li></ul></li><li><p>一个服务是工作节点上执行任务的定义。创建一个服务，指定了容器所使用的镜像和容器运行的命令。service是运行在worker nodes上的task的描述，service的描述包括使用哪个docker 镜像，以及在使用该镜像的容器中执行什么命令。</p><figure><img src="'+f+'" alt="1560069254431" tabindex="0" loading="lazy"><figcaption>1560069254431</figcaption></figure></li><li><p>task任务：一个任务包含了一个容器及其运行的命令。task是service的执行实体，task启动docker容器并在容器中执行任务</p><figure><img src="'+w+`" alt="1560069267443" tabindex="0" loading="lazy"><figcaption>1560069267443</figcaption></figure></li></ul><h2 id="_4-3-docker-swarm使用" tabindex="-1"><a class="header-anchor" href="#_4-3-docker-swarm使用" aria-hidden="true">#</a> 4.3 docker swarm使用</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>搭建步骤：

<span class="token number">1</span>、环境准备：
<span class="token number">1.1</span>、准备三台已近安装docker engine的Ubuntu系统主机（docker版本必须在1.12以上的版本，老版本不支持swarm）
<span class="token number">1.2</span>、docker容器主机的ip地址固定，集群中所有工作节点必须能访问该管理节点
<span class="token number">1.3</span>、集群管理节点必须使用相应的协议并且保证端口可用
	集群管理通信：TCP，端口2377
	节点通信：TCP和UDP，端口7946
	覆盖型网络：UDP，端口4789   overlay驱动
说明：三台容器主机的ip地址分别为：
<span class="token number">192.168</span>.200.138（管理节点）
<span class="token number">192.168</span>.200.139（工作节点）
<span class="token number">192.168</span>.200.140（工作节点）
主机名称分别为：manager1、work1以及work2
<span class="token function">vim</span> /etc/hostname  <span class="token punctuation">(</span>修改完成后需要重启<span class="token punctuation">)</span>


<span class="token number">2</span>、创建docker swarm
<span class="token number">2.1</span>、在manager1机器上创建docker swarm集群
<span class="token function">docker</span> swarm init --advertise-addr <span class="token number">192.168</span>.200.138
（--advertise-addr将该IP地址的机器设置为集群管理节点；如果是单节点，无需该参数）
<span class="token number">2.2</span>、查看管理节点集群信息：
<span class="token function">docker</span> <span class="token function">node</span> <span class="token function">ls</span>

<span class="token number">3</span>、向docker swarm中添加工作节点：在两个工作节点中分别执行如下命令，ip地址是manager节点的
<span class="token number">3.1</span>、添加两个work节点
<span class="token function">docker</span> swarm <span class="token function">join</span> <span class="token parameter variable">--token</span> xxx <span class="token number">192.168</span>.200.138:2377  （worker1）
<span class="token function">docker</span> swarm <span class="token function">join</span> <span class="token parameter variable">--token</span> xxx <span class="token number">192.168</span>.200.138:2377  （worker2）
（--token xxx:向指定集群中加入工作节点的认证信息，xxx认证信息是在创建docker swarm时产生的）
<span class="token number">3.2</span>、继续查看管理节点集群信息与之前的区别
<span class="token function">docker</span> <span class="token function">node</span> <span class="token function">ls</span>

<span class="token number">4</span>、在docker swarm中部署服务
在Docker Swarm集群中部署服务时，既可以使用Docker Hub上自带的镜像来启动服务，也可以使用自己通Dockerfile构建的镜像来启动服务。如果使用自己通过Dockerfile构建的镜像来启动服务那么必须先将镜像推送到Docker Hub中心仓库。为了方便读者的学习，这里以使用Docker Hub上自带的alpine镜像为例来部署集群服务
<span class="token number">4.1</span>、部署服务
<span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--replicas</span> <span class="token number">1</span> <span class="token parameter variable">--name</span> helloworld alpine <span class="token function">ping</span> docker.com
<span class="token function">docker</span> <span class="token function">service</span> create指令：用于在Swarm集群中创建一个基于alpine镜像的服务
--replicas参数：指定了该服务只有一个副本实例
--name参数：指定创建成功后的服务名称为helloworld
<span class="token function">ping</span> docker.com指令：表示服务启动后执行的命令

<span class="token number">5</span>.查看docker swarm集群中的服务
查看服务列表：docker <span class="token function">service</span> <span class="token function">ls</span>
查看部署具体服务的详细信息：docker <span class="token function">service</span> inspect 服务名称
查看服务在集群节点上的分配以及运行情况：docker <span class="token function">service</span> <span class="token function">ps</span> 服务名称

<span class="token number">6</span>、修改副本数量
在manager1上，更改服务副本的数量（创建的副本会随机分配到不同的节点）
<span class="token function">docker</span> <span class="token function">service</span> scale <span class="token assign-left variable">helloworld</span><span class="token operator">=</span><span class="token number">5</span>

<span class="token number">7</span>、删除服务（在管理节点）
<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">rm</span> 服务名称

<span class="token number">8</span>、访问服务
<span class="token number">8.1</span>、查看集群环境下的网络列表：docker network <span class="token function">ls</span>
<span class="token number">8.2</span>、在manager1上创建一overlay为驱动的网络（默认使用的网络连接ingress）
<span class="token function">docker</span> network create <span class="token parameter variable">-d</span><span class="token operator">=</span>overlay my-multi-host-network
<span class="token number">8.3</span>、在集群管理节点manager1上部署一个nginx服务
<span class="token function">docker</span> <span class="token function">service</span> create <span class="token punctuation">\\</span>
  <span class="token parameter variable">--network</span> my-multi-host-network <span class="token punctuation">\\</span>
  <span class="token parameter variable">--name</span> my-web <span class="token punctuation">\\</span>
  <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80 <span class="token punctuation">\\</span>
  <span class="token parameter variable">--replicas</span> <span class="token number">2</span> <span class="token punctuation">\\</span>
  nginx
<span class="token number">8.3</span>、在管理节点查看服务的运行情况：
<span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ps</span> my-web
<span class="token number">8.4</span>、访问测试
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_5-docker-compose编排工具" tabindex="-1"><a class="header-anchor" href="#_5-docker-compose编排工具" aria-hidden="true">#</a> 5 docker compose编排工具</h1><h2 id="_5-1-docker-compose介绍" tabindex="-1"><a class="header-anchor" href="#_5-1-docker-compose介绍" aria-hidden="true">#</a> 5.1 docker compose介绍</h2><p>根据前面所学的知识可知，想要使用Docker部署应用，就要先在应用中编写Dockerfile文件来构建镜像。同样，在微服务项目中，我们也需要为每一个服务编写Dockerfile文件来构建镜像。构建完成后，就可以根据每一个镜像使用docker run或者docker service create命令创建并启动容器，这样我们就可以访问容器中的服务了。</p><p>虽然使用上述方式可以部署微服务项目，但考虑到微服务项目可能有多个子服务组成，并且每个服务启动过程中都需要配置额外的参数（如-e配置环境变量、--network指定网络、磁盘挂载等等）。这种情况下，每次更新微服务后，都要手动运行指令来重新启动容器，这就显得相当麻烦了。针对这种多服务部署的情况，Docker提供了Docker Compose编排工具来对多服务应用进行统一部署。Compose是Docker的服务编排工具，主要用来构建基于Docker的复杂应用，Compose 通过一个配置文件来管理多个Docker容器，非常适合组合使用多个容器进行开发的场景。</p><p>通过该编排工具，可以使用yml（或yaml）文件来配置应用程序服务，然后只需要一条简单的服务部署指令就可以从配置中创建并启动所有服务。</p><h2 id="_5-2-docker-compose安装与卸载" tabindex="-1"><a class="header-anchor" href="#_5-2-docker-compose安装与卸载" aria-hidden="true">#</a> 5.2 docker compose安装与卸载</h2><p>安装docker compose</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>、环境要求：Docker Compose是依赖于Docker引擎的，所以在安装Docker Compose之前要确保机器上已经安装了Docker。https://github.com/docker/compose/releases （查看docker compose版本）

<span class="token number">2</span>、下载docker-compose工具
<span class="token function">curl</span> <span class="token parameter variable">-L</span> https://github.com/docker/compose/releases/download/1.24.0/docker-compose-<span class="token variable"><span class="token variable">\`</span><span class="token function">uname</span> <span class="token parameter variable">-s</span><span class="token variable">\`</span></span>-<span class="token variable"><span class="token variable">\`</span><span class="token function">uname</span> <span class="token parameter variable">-m</span><span class="token variable">\`</span></span> <span class="token parameter variable">-o</span> /usr/local/bin/docker-compose

<span class="token number">3</span>、设置docker compose可执行文件权限
<span class="token function">chmod</span> +x /usr/local/bin/docker-compose

<span class="token number">4</span>、查看docker compose版本
<span class="token function">docker-compose</span> <span class="token parameter variable">--version</span>


PS:卸载docker compose
<span class="token function">sudo</span> <span class="token function">rm</span> /usr/local/bin/docker-compose
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-3-docker-compose使用" tabindex="-1"><a class="header-anchor" href="#_5-3-docker-compose使用" aria-hidden="true">#</a> 5.3 docker compose使用</h2><h3 id="_5-3-1-例子" tabindex="-1"><a class="header-anchor" href="#_5-3-1-例子" aria-hidden="true">#</a> 5.3.1 例子</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>步骤：分为三步<span class="token punctuation">(</span>在创建的一个空目录下执行<span class="token punctuation">)</span>
<span class="token number">1</span>、编写Dockerfile文件（为每个服务构建需要的镜像，方便迁移-不是必须的）
<span class="token number">2</span>、编写docker-compose.yml文件（编写部署服务相关指令）
<span class="token number">3</span>、运行docker-compose up（启动yml文件中服务）

案例：
<span class="token number">1</span>、准备：两个镜像（本次演示就不通过Dockerfile构建了）
<span class="token function">docker</span> pull mysql:5.7
<span class="token function">docker</span> pull wordpress

<span class="token number">2</span>、需要新建一个空白目录，例如rwtest。新建一个docker-compose.yml,编辑该文件：
version: <span class="token string">&#39;3&#39;</span>
services:
   db:
     image: mysql:5.7
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: wordpress
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     ports:
       - <span class="token string">&quot;8001:80&quot;</span>
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_USER: wordpress
       WORDPRESS_DB_PASSWORD: wordpress
volumes:
    db_data:
        
该文件中内容：新建db和wordpress容器。等同于：
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> db <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token parameter variable">-d</span> mysql
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> some-wordpress <span class="token parameter variable">--link</span> db:mysql <span class="token parameter variable">-p</span> <span class="token number">8002</span>:80 <span class="token parameter variable">-d</span> wordpress

<span class="token number">3</span>、启动docker compose
<span class="token function">docker-compose</span> up

<span class="token number">4</span>、浏览器访问：http://ip:8001

<span class="token number">5</span>、停止/重启服务：docker-compose stop/restart
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-3-2-docker-compose指令说明" tabindex="-1"><a class="header-anchor" href="#_5-3-2-docker-compose指令说明" aria-hidden="true">#</a> 5.3.2 docker compose指令说明</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> <span class="token number">1</span>	version: <span class="token string">&#39;3&#39;</span>
 <span class="token number">2</span>	services:
 <span class="token number">3</span>	  web:
 <span class="token number">4</span>	    image: id/imagename:lable
 <span class="token number">5</span>	    restart: on-failure
 <span class="token number">6</span>	    container_name: my-web-container
 <span class="token number">7</span>	    ports:
 <span class="token number">8</span>	      - <span class="token number">8080</span>:8080
 <span class="token number">9</span>	   	networks:
 <span class="token number">10</span>	      - example-net
 <span class="token number">11</span>	    depends_on:
 <span class="token number">12</span>	      - db
 <span class="token number">13</span>	    deploy:
 <span class="token number">14</span>	      replicas: <span class="token number">2</span>
 <span class="token number">15</span>	      restart_policy:
 <span class="token number">16</span>	        condition: on-failure
 <span class="token number">17</span>	  db:
 <span class="token number">18</span>	    image: mysql:5.6
 <span class="token number">19</span>	    restart: on-failure
 <span class="token number">20</span>	    container_name: my-mysql-container	
 <span class="token number">21</span>	    ports:
 <span class="token number">22</span>	      - <span class="token number">3306</span>:3306
 <span class="token number">23</span>	    volumes:
 <span class="token number">24</span>	      - example-mysql:/var/lib/mysql
 <span class="token number">25</span>	    networks:
 <span class="token number">26</span>	      - example-net
 <span class="token number">27</span>	    environment:
 <span class="token number">28</span>	      MYSQL_ROOT_PASSWORD: root
 <span class="token number">29</span>	      MYSQL_DATABASE: mysql_database
 <span class="token number">30</span>	    deploy:
 <span class="token number">31</span>	      replicas: <span class="token number">1</span>
 <span class="token number">32</span>	      restart_policy:
 <span class="token number">33</span>	        condition: on-failure
 <span class="token number">34</span>	      placement:
 <span class="token number">35</span>	        constraints: <span class="token punctuation">[</span>node.role <span class="token operator">==</span> manager<span class="token punctuation">]</span>
 <span class="token number">36</span>	networks:
 <span class="token number">37</span>	  example-net:
 <span class="token number">38</span>	volumes:
 <span class="token number">39</span>	  example-mysql:

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>version：version通常在一个docker-compose.yml文件的最顶部，用来表示文件内容的约束版本（类似于XML文件约束）（版本越高，支持的指令越多）</li><li>services用来声明服务，在services下的所有同缩进的应用名称都代表一个服务，如上面示例中的web和db。在进行多服务部署的时候，有多少个服务需要同时部署，就需要在services参数下面声明并配置多少个服务 <ul><li>image：容器启动需要依赖的镜像（如果本地没有会自动pull）</li><li>restart：服务重启策略 <ul><li>restart: &quot;no&quot; #服务默认值为no，即服务失败后没有任何动作</li><li>restart: always #表示服务会一直重新启动</li><li>restart: on-failure #表示服务提示失败错误后会重新启动</li><li>restart: unless-stopped #表示只有服务在停止后才会重启</li></ul></li><li>container_name：指定容器名称</li><li>ports：指定服务向外暴露的端口</li><li>networks：指定容器使用的网络</li><li>depends_on：服务依赖决定了服务的依赖关系，如示例中的web依赖db，所以db服务会先于web服务启动，但并不表示db服务完全启动成功后才启动web服务，它只决定启动的先后顺序而已</li><li>deploy：deploy参数是Docker Compose针对Swarm集群部署提供的，子参数专门用于指定与服务部署和运行相关的配置 <ul><li>replicas：表示服务实例的副本数量</li><li>restart_policy：estart_policy参数同前面介绍的restart类似，都是用来配置服务重启策略的，只是该属性配置在deploy参数下，并只在集群环境下生效。该参数包含多个子属性及属性值 <ul><li>condition: on-failure #表示服务重启的条件，值有none、on-failure和any</li><li>delay: 5s #表示重启服务之间等待时间，默认为0</li><li>max_attempts: 3 #表示失败后尝试重启的次数</li><li>window: 120s #表示等待多久来确定服务是否启动成功</li></ul></li><li>placement：placement用来配置指定位置的约束，当服务在Swarm集群环境下部署时会随机分配到管理节点和其他工作节点上。在上述示例中由于将mysql数据挂载到了本机example-mysql数据卷中，所以使用了placement的子参数constraints: [node.role == manager]指定该服务只在manager管理节点上运行 :</li></ul></li><li>environment用于配置服务启动时需要的环境变量。如上述示例中MYSQL_ROOT_PASSWORD表示数据库root用户的密码，MYSQL_DATABASE表示数据库启动后自动创建的数据库。</li></ul></li><li>networks：用于配置服务网络</li><li>volumes：目录挂载，上述示例中是将mysql数据挂载到本地example-mysql数据卷中，如果该数据卷不存在，服务启动时也会默认创建</li></ul>`,86),B={href:"https://docs.docker.com/compose/compose-file/",target:"_blank",rel:"noopener noreferrer"},S=a(`<h1 id="_6-docker的web可视化管理工具" tabindex="-1"><a class="header-anchor" href="#_6-docker的web可视化管理工具" aria-hidden="true">#</a> 6 docker的web可视化管理工具</h1><h2 id="_6-1-常用工具介绍" tabindex="-1"><a class="header-anchor" href="#_6-1-常用工具介绍" aria-hidden="true">#</a> 6.1 常用工具介绍</h2><p>当 Docker 部署规模逐步变大后，可视化监控容器环境的性能和健康状态将会变得越来越重要。 Docker的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。常用工具如下：</p><p>1、docker UI（local）</p><p>2、shipyard（停止维护了）</p><p>3、portainer</p><p>4、daocloud</p><h2 id="_6-2-工具使用" tabindex="-1"><a class="header-anchor" href="#_6-2-工具使用" aria-hidden="true">#</a> 6.2 工具使用</h2><h3 id="_6-2-1-docker-ui" tabindex="-1"><a class="header-anchor" href="#_6-2-1-docker-ui" aria-hidden="true">#</a> 6.2.1 docker UI</h3><p>安装docker UI</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>、拉取docker UI镜像
<span class="token function">docker</span> pull uifd/ui-for-docker

<span class="token number">2</span>、创建容器
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">9000</span>:9000 <span class="token parameter variable">--privileged</span> <span class="token parameter variable">-v</span> /var/run/docker.sock:/var/run/docker.sock uifd/ui-for-docker
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+y+`" alt="1560075565234" tabindex="0" loading="lazy"><figcaption>1560075565234</figcaption></figure><ul><li>优点： <ul><li>支持容器管理</li><li>支持镜像管理</li><li>基于docker api，自身也是一个容器。</li><li>稳定性高</li><li>可动态显示显示容器之间关系图</li><li>容器管理，增加端口映射，增加系统变量、映射目录等</li></ul></li><li>缺点： <ul><li>没有登录验证，因为没有登录体系，目前解决办法是，只开放本地访问，或者通过TLS来对权限进行控制。</li><li>无法分配某容器给某用户。</li><li>不支持多主机。</li><li>不支持集群swarm等</li><li>功能少</li></ul></li></ul><h3 id="_6-2-2-portainer" tabindex="-1"><a class="header-anchor" href="#_6-2-2-portainer" aria-hidden="true">#</a> 6.2.2 portainer</h3><h4 id="_6-2-2-1-安装portainer" tabindex="-1"><a class="header-anchor" href="#_6-2-2-1-安装portainer" aria-hidden="true">#</a> 6.2.2.1 安装portainer</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">9001</span>:9000 <span class="token parameter variable">-v</span> /var/run/docker.sock:/var/run/docker.sock portainer/portainer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+D+`" alt="1560075629895" tabindex="0" loading="lazy"><figcaption>1560075629895</figcaption></figure><h4 id="_6-2-2-2-挂载远程节点-修改远程节点配置" tabindex="-1"><a class="header-anchor" href="#_6-2-2-2-挂载远程节点-修改远程节点配置" aria-hidden="true">#</a> 6.2.2.2 挂载远程节点（修改远程节点配置）</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>、编辑该文件
<span class="token function">vim</span> /lib/systemd/system/docker.service

<span class="token number">2</span>、删除配置文件中内容
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/bin/dockerd xxx<span class="token punctuation">(</span>删除这部分内容<span class="token punctuation">)</span>

<span class="token number">3</span>、在daemon.json文件中添加如下内容：所有服务器都可以访问
<span class="token string">&quot;hosts&quot;</span>:<span class="token punctuation">[</span><span class="token string">&quot;tcp://0.0.0.0:2375&quot;</span>,<span class="token string">&quot;unix:///var/run/docker.sock&quot;</span><span class="token punctuation">]</span>

<span class="token number">4</span>、重启docker
systemctl daemon-reload
systemctl restart <span class="token function">docker</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点</p><ol><li>支持容器管理、镜像管理</li><li>轻量级，消耗资源少</li><li>基于docker api，安全性高，可指定docker api端口，支持TLS证书认证。</li><li>支持权限分配</li><li>支持集群</li></ol><p>缺点</p><ol><li>功能不够强大。</li><li>容器创建后，无法通过后台增加端口。</li></ol><h3 id="_6-2-3-daocloud" tabindex="-1"><a class="header-anchor" href="#_6-2-3-daocloud" aria-hidden="true">#</a> 6.2.3 daocloud</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>执行该命令：
<span class="token function">curl</span> <span class="token parameter variable">-sSL</span> https://get.daocloud.io/daomonit/install.sh <span class="token operator">|</span> <span class="token function">sh</span> <span class="token parameter variable">-s</span> 24a7c865945f25697fe9255dad8e54eb431d785b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+_+'" alt="1560075901178" tabindex="0" loading="lazy"><figcaption>1560075901178</figcaption></figure><p>优点：</p><ol><li>支持镜像管理、容器管理。</li><li>支持控制台命令</li><li>容器资源消耗监控</li><li>支持集群可以随意增加节点</li><li>中文平台</li><li>镜像下载</li><li>容器扩容、管理</li></ol><p>缺点</p><ol><li>管理平台无法部署到本地服务器</li><li>部分高级功能收费</li></ol>',30);function Q(M,R){const e=r("ExternalLinkIcon");return c(),t("div",null,[C,s("p",null,[n("通过宿主机访问："),s("a",E,[n("http://ip"),i(e)]),n(":port")]),I,s("p",null,[n("其他配置可参考："),s("a",B,[n("https://docs.docker.com/compose/compose-file/"),i(e)])]),S])}const O=l(x,[["render",Q],["__file","docker-v2-02.html.vue"]]);export{O as default};
