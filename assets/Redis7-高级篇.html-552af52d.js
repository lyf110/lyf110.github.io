const e=JSON.parse('{"key":"v-77918ee7","path":"/database/redis/atguigu2023/Redis7-%E9%AB%98%E7%BA%A7%E7%AF%87.html","title":"二、Redis7-高级篇","lang":"zh-CN","frontmatter":{"title":"二、Redis7-高级篇","date":"2023-05-11T19:58:23.000Z","order":2,"category":["数据库","Redis","分布式缓存","中间件"],"tag":["数据库","Redis","分布式缓存","中间件"],"author":{"name":"liu yang fang","link":"https://github.com/lyf110"},"description":"二、Redis7-高级篇 1 Redis单线程 VS 多线程 1.1 从几道简单的面试题说起 Redis到底是单线程还是多线程？ IO多路复用听说过吗？ Redis为什么这么快？ 1.2 为什么Redis在4.0版本之前都是单线程 1.2.1 是什么？ 这种问法其实并不严谨，为啥这么说呢? Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问是否单线程也不太严谨。 1 版本3.x ，最早版本，也就是大家口口相传的redis是单线程，阳哥2016年讲解的redis就是3.X的版本。 2 版本4.x，严格意义来说也不是单线程，而是负责处理客户端请求的线程是单线程，但是开始加了点多线程的东西(异步删除)。---貌似 3 2020年5月版本的6.0.x后及2022年出的7.0版本后，告别了大家印象中的单线程，用一种全新的多线程来解决问题。---实锤","head":[["meta",{"property":"og:url","content":"https://github.com/lyf110/database/redis/atguigu2023/Redis7-%E9%AB%98%E7%BA%A7%E7%AF%87.html"}],["meta",{"property":"og:site_name","content":"lyf blog"}],["meta",{"property":"og:title","content":"二、Redis7-高级篇"}],["meta",{"property":"og:description","content":"二、Redis7-高级篇 1 Redis单线程 VS 多线程 1.1 从几道简单的面试题说起 Redis到底是单线程还是多线程？ IO多路复用听说过吗？ Redis为什么这么快？ 1.2 为什么Redis在4.0版本之前都是单线程 1.2.1 是什么？ 这种问法其实并不严谨，为啥这么说呢? Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问是否单线程也不太严谨。 1 版本3.x ，最早版本，也就是大家口口相传的redis是单线程，阳哥2016年讲解的redis就是3.X的版本。 2 版本4.x，严格意义来说也不是单线程，而是负责处理客户端请求的线程是单线程，但是开始加了点多线程的东西(异步删除)。---貌似 3 2020年5月版本的6.0.x后及2022年出的7.0版本后，告别了大家印象中的单线程，用一种全新的多线程来解决问题。---实锤"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/lyf110/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"二、Redis7-高级篇"}],["meta",{"property":"article:author","content":"liu yang fang"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"分布式缓存"}],["meta",{"property":"article:tag","content":"中间件"}],["meta",{"property":"article:published_time","content":"2023-05-11T19:58:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二、Redis7-高级篇\\",\\"image\\":[\\"https://github.com/lyf110/\\"],\\"datePublished\\":\\"2023-05-11T19:58:23.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"liu yang fang\\",\\"link\\":\\"https://github.com/lyf110\\"}]}"]]},"headers":[{"level":2,"title":"1 Redis单线程 VS 多线程","slug":"_1-redis单线程-vs-多线程","link":"#_1-redis单线程-vs-多线程","children":[{"level":3,"title":"1.1 从几道简单的面试题说起","slug":"_1-1-从几道简单的面试题说起","link":"#_1-1-从几道简单的面试题说起","children":[]},{"level":3,"title":"1.2 为什么Redis在4.0版本之前都是单线程","slug":"_1-2-为什么redis在4-0版本之前都是单线程","link":"#_1-2-为什么redis在4-0版本之前都是单线程","children":[]},{"level":3,"title":"1.3 单线程的Redis都已经这么优秀了，为什么从4.x开始逐渐引入多线程特性","slug":"_1-3-单线程的redis都已经这么优秀了-为什么从4-x开始逐渐引入多线程特性","link":"#_1-3-单线程的redis都已经这么优秀了-为什么从4-x开始逐渐引入多线程特性","children":[]},{"level":3,"title":"1.4 Redis6/7的多线程特性和I/O多路复用入门篇","slug":"_1-4-redis6-7的多线程特性和i-o多路复用入门篇","link":"#_1-4-redis6-7的多线程特性和i-o多路复用入门篇","children":[]},{"level":3,"title":"1.5 Unix网络编程中的五种I/O模型","slug":"_1-5-unix网络编程中的五种i-o模型","link":"#_1-5-unix网络编程中的五种i-o模型","children":[]},{"level":3,"title":"1.6 Redis是否默认开启了多线程呢？","slug":"_1-6-redis是否默认开启了多线程呢","link":"#_1-6-redis是否默认开启了多线程呢","children":[]},{"level":3,"title":"1.7 Redis架构设计的演变目的：为了使Redis更快","slug":"_1-7-redis架构设计的演变目的-为了使redis更快","link":"#_1-7-redis架构设计的演变目的-为了使redis更快","children":[]}]},{"level":2,"title":"2 BigKey","slug":"_2-bigkey","link":"#_2-bigkey","children":[{"level":3,"title":"2.1 面试题","slug":"_2-1-面试题","link":"#_2-1-面试题","children":[]},{"level":3,"title":"2.2 More Key案例演示","slug":"_2-2-more-key案例演示","link":"#_2-2-more-key案例演示","children":[]},{"level":3,"title":"2.3 Big Key案例","slug":"_2-3-big-key案例","link":"#_2-3-big-key案例","children":[]},{"level":3,"title":"2.4 BigKey生产调优","slug":"_2-4-bigkey生产调优","link":"#_2-4-bigkey生产调优","children":[]}]},{"level":2,"title":"3 缓存双写一致性之更新策略探讨","slug":"_3-缓存双写一致性之更新策略探讨","link":"#_3-缓存双写一致性之更新策略探讨","children":[{"level":3,"title":"3.1 面试题","slug":"_3-1-面试题","link":"#_3-1-面试题","children":[]},{"level":3,"title":"3.2 缓存与数据库双写一致性，谈谈你的理解","slug":"_3-2-缓存与数据库双写一致性-谈谈你的理解","link":"#_3-2-缓存与数据库双写一致性-谈谈你的理解","children":[]},{"level":3,"title":"3.3 数据库与缓存一致性的几种更新策略","slug":"_3-3-数据库与缓存一致性的几种更新策略","link":"#_3-3-数据库与缓存一致性的几种更新策略","children":[]}]},{"level":2,"title":"4 Redis与MySQL数据双写一致性工程落地案例","slug":"_4-redis与mysql数据双写一致性工程落地案例","link":"#_4-redis与mysql数据双写一致性工程落地案例","children":[{"level":3,"title":"4.1 复习","slug":"_4-1-复习","link":"#_4-1-复习","children":[]},{"level":3,"title":"4.2 canal简介","slug":"_4-2-canal简介","link":"#_4-2-canal简介","children":[]},{"level":3,"title":"4.3 使用canal完成的双写一致性编码","slug":"_4-3-使用canal完成的双写一致性编码","link":"#_4-3-使用canal完成的双写一致性编码","children":[]}]},{"level":2,"title":"5 Redis的高级数据结构bitmap/hyperloglog/GEO","slug":"_5-redis的高级数据结构bitmap-hyperloglog-geo","link":"#_5-redis的高级数据结构bitmap-hyperloglog-geo","children":[{"level":3,"title":"5.1 面试题","slug":"_5-1-面试题","link":"#_5-1-面试题","children":[]},{"level":3,"title":"5.2 统计的类型","slug":"_5-2-统计的类型","link":"#_5-2-统计的类型","children":[]},{"level":3,"title":"5.3 Hyperloglog","slug":"_5-3-hyperloglog","link":"#_5-3-hyperloglog","children":[]},{"level":3,"title":"5.4 GEO","slug":"_5-4-geo","link":"#_5-4-geo","children":[]},{"level":3,"title":"5.5 bitmap","slug":"_5-5-bitmap","link":"#_5-5-bitmap","children":[]}]},{"level":2,"title":"6 布隆过滤器 BloomFilter","slug":"_6-布隆过滤器-bloomfilter","link":"#_6-布隆过滤器-bloomfilter","children":[{"level":3,"title":"6.1 面试题","slug":"_6-1-面试题","link":"#_6-1-面试题","children":[]},{"level":3,"title":"6.2 是什么","slug":"_6-2-是什么","link":"#_6-2-是什么","children":[]},{"level":3,"title":"6.3 能干嘛","slug":"_6-3-能干嘛","link":"#_6-3-能干嘛","children":[]},{"level":3,"title":"6.4 布隆过滤器原理","slug":"_6-4-布隆过滤器原理","link":"#_6-4-布隆过滤器原理","children":[]},{"level":3,"title":"6.5 布隆过滤器的使用场景","slug":"_6-5-布隆过滤器的使用场景","link":"#_6-5-布隆过滤器的使用场景","children":[]},{"level":3,"title":"6.6 尝试手写布隆过滤器，结合bitmap体会下思想","slug":"_6-6-尝试手写布隆过滤器-结合bitmap体会下思想","link":"#_6-6-尝试手写布隆过滤器-结合bitmap体会下思想","children":[]}]},{"level":2,"title":"7 Redis的生产环境问题（缓存预热、缓存雪崩、缓存击穿、缓存穿透）","slug":"_7-redis的生产环境问题-缓存预热、缓存雪崩、缓存击穿、缓存穿透","link":"#_7-redis的生产环境问题-缓存预热、缓存雪崩、缓存击穿、缓存穿透","children":[{"level":3,"title":"7.1 面试题","slug":"_7-1-面试题","link":"#_7-1-面试题","children":[]},{"level":3,"title":"7.2 缓存预热","slug":"_7-2-缓存预热","link":"#_7-2-缓存预热","children":[]},{"level":3,"title":"7.3 缓存雪崩","slug":"_7-3-缓存雪崩","link":"#_7-3-缓存雪崩","children":[]},{"level":3,"title":"7.4 缓存穿透","slug":"_7-4-缓存穿透","link":"#_7-4-缓存穿透","children":[]},{"level":3,"title":"7.5 缓存击穿","slug":"_7-5-缓存击穿","link":"#_7-5-缓存击穿","children":[]},{"level":3,"title":"7.6 总结","slug":"_7-6-总结","link":"#_7-6-总结","children":[]}]},{"level":2,"title":"8 手写Redis的分布式锁","slug":"_8-手写redis的分布式锁","link":"#_8-手写redis的分布式锁","children":[{"level":3,"title":"8.1 面试题","slug":"_8-1-面试题","link":"#_8-1-面试题","children":[]},{"level":3,"title":"8.2 锁按是否集群模式分为","slug":"_8-2-锁按是否集群模式分为","link":"#_8-2-锁按是否集群模式分为","children":[]},{"level":3,"title":"8.3 一个可靠的分布式需要满足以下的条件","slug":"_8-3-一个可靠的分布式需要满足以下的条件","link":"#_8-3-一个可靠的分布式需要满足以下的条件","children":[]},{"level":3,"title":"8.4 Redis实现分布式锁","slug":"_8-4-redis实现分布式锁","link":"#_8-4-redis实现分布式锁","children":[]},{"level":3,"title":"8.5 单机锁","slug":"_8-5-单机锁","link":"#_8-5-单机锁","children":[]},{"level":3,"title":"8.6 redis 分布式锁V1.0","slug":"_8-6-redis-分布式锁v1-0","link":"#_8-6-redis-分布式锁v1-0","children":[]},{"level":3,"title":"8.7 redis分布式锁V2.0 考虑宕机的情况，防止死锁","slug":"_8-7-redis分布式锁v2-0-考虑宕机的情况-防止死锁","link":"#_8-7-redis分布式锁v2-0-考虑宕机的情况-防止死锁","children":[]},{"level":3,"title":"8.8 redis分布式锁V3.0，防止误删别的线程的key的","slug":"_8-8-redis分布式锁v3-0-防止误删别的线程的key的","link":"#_8-8-redis分布式锁v3-0-防止误删别的线程的key的","children":[]},{"level":3,"title":"8.9 redis分布式锁V4.0，删除锁的逻辑不是原子的，需要使用Lua脚本来保证原子性","slug":"_8-9-redis分布式锁v4-0-删除锁的逻辑不是原子的-需要使用lua脚本来保证原子性","link":"#_8-9-redis分布式锁v4-0-删除锁的逻辑不是原子的-需要使用lua脚本来保证原子性","children":[]},{"level":3,"title":"8.10 实现锁的重入+工厂设计模式","slug":"_8-10-实现锁的重入-工厂设计模式","link":"#_8-10-实现锁的重入-工厂设计模式","children":[]},{"level":3,"title":"8.11 自动续期","slug":"_8-11-自动续期","link":"#_8-11-自动续期","children":[]},{"level":3,"title":"8.12 总结","slug":"_8-12-总结","link":"#_8-12-总结","children":[]}]},{"level":2,"title":"9 RedLock算法和底层源码解析","slug":"_9-redlock算法和底层源码解析","link":"#_9-redlock算法和底层源码解析","children":[{"level":3,"title":"9.1 面试中关于自研一把分布式的考法回答","slug":"_9-1-面试中关于自研一把分布式的考法回答","link":"#_9-1-面试中关于自研一把分布式的考法回答","children":[]},{"level":3,"title":"9.2 Redis分布式锁-RedLock红锁算法（Distributed lock with Redis）","slug":"_9-2-redis分布式锁-redlock红锁算法-distributed-lock-with-redis","link":"#_9-2-redis分布式锁-redlock红锁算法-distributed-lock-with-redis","children":[]},{"level":3,"title":"9.3 使用Redisson进行编码改造V7.0（对应周阳老师V9.0）","slug":"_9-3-使用redisson进行编码改造v7-0-对应周阳老师v9-0","link":"#_9-3-使用redisson进行编码改造v7-0-对应周阳老师v9-0","children":[]},{"level":3,"title":"9.4 Redisson源码解析","slug":"_9-4-redisson源码解析","link":"#_9-4-redisson源码解析","children":[]},{"level":3,"title":"9.5 Redisson多机案例","slug":"_9-5-redisson多机案例","link":"#_9-5-redisson多机案例","children":[]}]},{"level":2,"title":"10 Redis的缓存过期淘汰策略","slug":"_10-redis的缓存过期淘汰策略","link":"#_10-redis的缓存过期淘汰策略","children":[{"level":3,"title":"10.1 粉丝反馈的面试题","slug":"_10-1-粉丝反馈的面试题","link":"#_10-1-粉丝反馈的面试题","children":[]},{"level":3,"title":"10.2 Redis内存满了怎么办","slug":"_10-2-redis内存满了怎么办","link":"#_10-2-redis内存满了怎么办","children":[]},{"level":3,"title":"10.3 往redis里写的数据是怎么没了的？它如何删除的？","slug":"_10-3-往redis里写的数据是怎么没了的-它如何删除的","link":"#_10-3-往redis里写的数据是怎么没了的-它如何删除的","children":[]},{"level":3,"title":"10.4 redis缓存淘汰策略","slug":"_10-4-redis缓存淘汰策略","link":"#_10-4-redis缓存淘汰策略","children":[]},{"level":3,"title":"10.5 redis缓存淘汰策略配置性能建议","slug":"_10-5-redis缓存淘汰策略配置性能建议","link":"#_10-5-redis缓存淘汰策略配置性能建议","children":[]}]},{"level":2,"title":"11 Redis的五大数据结构的底层源码解读","slug":"_11-redis的五大数据结构的底层源码解读","link":"#_11-redis的五大数据结构的底层源码解读","children":[]},{"level":2,"title":"12 Redis为什么这么快？高性能设计之epoll和IO多路复用深度解析","slug":"_12-redis为什么这么快-高性能设计之epoll和io多路复用深度解析","link":"#_12-redis为什么这么快-高性能设计之epoll和io多路复用深度解析","children":[]},{"level":2,"title":"13 终章&总结","slug":"_13-终章-总结","link":"#_13-终章-总结","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":181.32,"words":54397},"filePathRelative":"database/redis/atguigu2023/Redis7-高级篇.md","localizedDate":"2023年5月12日","excerpt":"<h1> 二、Redis7-高级篇</h1>\\n<h2> 1 Redis单线程 VS 多线程</h2>\\n<h3> 1.1 从几道简单的面试题说起</h3>\\n<ul>\\n<li><strong>Redis到底是单线程还是多线程？</strong></li>\\n<li><strong>IO多路复用听说过吗？</strong></li>\\n<li><strong>Redis为什么这么快？</strong></li>\\n</ul>\\n<h3> 1.2 为什么Redis在4.0版本之前都是单线程</h3>\\n<h4> 1.2.1 是什么？</h4>\\n<p>这种问法其实并不严谨，为啥这么说呢?</p>\\n<blockquote>\\n<p>Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问是否单线程也不太严谨。</p>\\n<p>1 版本3.x ，最早版本，也就是大家口口相传的redis是单线程，阳哥2016年讲解的redis就是3.X的版本。</p>\\n<p>2 版本4.x，严格意义来说也不是单线程，而是负责处理客户端请求的线程是单线程，但是<strong>开始加了点多线程的东西(异步删除)</strong>。---貌似</p>\\n<p>3 2020年5月版本的6.0.x后及2022年出的7.0版本后，<strong>告别了大家印象中的单线程，用一种全新的多线程来解决问题。</strong>---实锤</p>\\n</blockquote>","copyright":{"author":"liu yang fang","license":"Apache License 2.0"},"autoDesc":true}');export{e as data};
