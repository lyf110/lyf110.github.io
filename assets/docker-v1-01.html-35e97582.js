import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as d,c as l,a as e,b as a,d as n,e as i}from"./app-5f6064b2.js";const c="/assets/1565137893494-203ea117.png",p="/assets/1554250698787-263dd646.png",o="/assets/1554250792335-86f3d734.png",u="/assets/1554250879469-057fe352.png",h="/assets/1554250976402-24509a33.png",g="/assets/1554251078724-2a641926.png",m="/assets/1554255070258-171568fd.png",v="/assets/1554255252421-a581bfc6.png",k="/assets/1554268579991-9e0357d7.png",b="/assets/1563846522694-1a761b47.png",f="/assets/1554268730431-6222a98f.png",_="/assets/1554268787279-356d6717.png",x="/assets/1554268839313-fe096efe.png",y="/assets/1554268883192-ac9a5ccf.png",D="/assets/1554268977335-c055c3ab.png",w="/assets/1554269036684-db7f0b53.png",S="/assets/1554269087361-160c5256.png",z="/assets/1554269473918-845b108b.png",M="/assets/1554269542721-868eb998.png",R="/assets/1554269600589-b98703c4.png",q="/assets/1554269647203-47cb199e.png",O="/assets/1554269753673-e41c16f4.png",I="/assets/1554269801076-702b8455.png",A="/assets/1554269834652-ec05b2bd.png",E="/assets/1554269906669-6fc0e2f2.png",P="/assets/1554269949611-6bd0e045.png",T="/assets/1554269990586-8bd355ad.png",N="/assets/1554270072434-dbaedfa3.png",C="/assets/1554270157882-abb56698.png",L="/assets/1554270195286-031c307d.png",H="/assets/1554275876795-d8cb0242.png",V="/assets/1554275938383-59f86633.png",U="/assets/1554276054400-f8c908b2.png",Q="/assets/1564414004388-bf3f8056.png",j="/assets/1554276119395-0d2c8a11.png",W="/assets/1563838223200-c001cc04.png",B="/assets/1563838278876-1eed2a6e.png",Y="/assets/1563838515415-84aaefea.png",$="/assets/1563838882452-fff97253.png",X={},F=i('<h1 id="容器部署解决方案docker" tabindex="-1"><a class="header-anchor" href="#容器部署解决方案docker" aria-hidden="true">#</a> 容器部署解决方案Docker</h1><figure><img src="'+c+'" alt="1565137893494" tabindex="0" loading="lazy"><figcaption>1565137893494</figcaption></figure><p>反馈：</p><ul><li>集群测试：创建了集群的客户端 <ul><li>就是客户端创建不一样</li><li>剩下的api的操作一模一样</li></ul></li><li>spring data es：配置集群的节点信息 ElasticsearchTemplate</li><li>加油</li><li>加班</li><li>加班</li><li>加班</li><li>技术方向上： 一个个独立业务单元（服务） 认知过程（学过专业） 看看书。</li></ul><p>课程回顾：</p><ul><li>原生api：单节点 集群 jedis（JedisPool） JedisCluster</li><li>封装后的api：ElasticsearchTemplate RedisTemplate</li></ul><p>1、通过java的客户端操作es服务（原生的api）</p><ul><li>创建索引、删除索引</li><li>创建映射</li><li>向索引中添加数据、更新、删除、批量添加</li><li>检索：根据字符串、词条、模糊、相似度、区间段、查询所有、组合查询、高亮显示</li></ul><p>2、通过spring data es进行操作：ElasticsearchTemplate</p><ul><li>配置ElasticsearchTemplate（在spring配置文件中）</li><li>操作：简单</li></ul><p>3、搭建es的集群（伪集群）</p><ul><li>步骤：添加3个节点</li><li>配置文件：指定了集群名称、节点名称、http port、tcp port、节点相互通信</li></ul><p>学习目标：运维的活 （可能会涉及到一些Linux的操作）</p><p>目标1：了解Docker与虚拟机的不同点，相比的优势<br> 目标2：掌握Docker的启动方法<br><strong>目标3：掌握Docker镜像操作</strong><br><strong>目标4：掌握Docker容器操作</strong><br> 目标5：掌握Mysql tomcat Nginx Redis等容器的部署方法<br> 目标6：掌握 Docker的备份与迁移方法</p><p>要求：深入操作系统 （基础镜像：OS）</p><h1 id="第1章-docker简介" tabindex="-1"><a class="header-anchor" href="#第1章-docker简介" aria-hidden="true">#</a> 第1章 Docker简介</h1><h2 id="_1-1-虚拟化" tabindex="-1"><a class="header-anchor" href="#_1-1-虚拟化" aria-hidden="true">#</a> 1.1 虚拟化</h2><h3 id="_1-1-1什么是虚拟化" tabindex="-1"><a class="header-anchor" href="#_1-1-1什么是虚拟化" aria-hidden="true">#</a> 1.1.1什么是虚拟化</h3><p>在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，<strong>打破实体结构间的不可切割的障碍</strong>，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p><p>虚拟化：充分的利用物理资源不要浪费资源。</p><p>在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用</p><p>虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip keepalived vip ip漂移)、桌面虚拟化、服务虚拟化、<strong>虚拟机</strong>等等。</p><h3 id="_1-1-2虚拟化种类" tabindex="-1"><a class="header-anchor" href="#_1-1-2虚拟化种类" aria-hidden="true">#</a> 1.1.2虚拟化种类</h3><h4 id="_1-1-2-1-全虚拟化架构" tabindex="-1"><a class="header-anchor" href="#_1-1-2-1-全虚拟化架构" aria-hidden="true">#</a> 1.1.2.1 全虚拟化架构</h4><p>虚拟机的监视器（hypervisor）是类似于用户的应用程序运行在主机的OS之上，如VMware的workstation，这种虚拟化产品提供了虚拟的硬件。</p><figure><img src="'+p+'" alt="1554250698787" tabindex="0" loading="lazy"><figcaption>1554250698787</figcaption></figure><h4 id="_1-1-2-2-os层虚拟化架构" tabindex="-1"><a class="header-anchor" href="#_1-1-2-2-os层虚拟化架构" aria-hidden="true">#</a> 1.1.2.2 OS层虚拟化架构</h4><figure><img src="'+o+'" alt="1554250792335" tabindex="0" loading="lazy"><figcaption>1554250792335</figcaption></figure><h4 id="_1-1-2-3-硬件层虚拟化" tabindex="-1"><a class="header-anchor" href="#_1-1-2-3-硬件层虚拟化" aria-hidden="true">#</a> 1.1.2.3 硬件层虚拟化</h4><figure><img src="'+u+'" alt="1554250879469" tabindex="0" loading="lazy"><figcaption>1554250879469</figcaption></figure><p>硬件层的虚拟化具有高性能和隔离性，因为hypervisor直接在硬件上运行，有利于控制VM的OS访问硬件资源，使用这种解决方案的产品有VMware ESXi 和 Xen server</p><p>Hypervisor是一种运行在物理服务器和操作系统之间的中间软件层,可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统，它可以协调访问服务器上的所有物理设备和虚拟机，也叫虚拟机监视器（Virtual Machine Monitor，VMM）。</p><p>Hypervisor是所有虚拟化技术的核心。当服务器启动并执行Hypervisor时，它会给每一台虚拟机分配适量的内存、CPU、网络和磁盘，并加载所有虚拟机的客户操作系统。 宿主机</p><p>Hypervisor是所有虚拟化技术的核心，软硬件架构和管理更高效、更灵活，硬件的效能能够更好地发挥出来。常见的产品有：VMware、KVM、Xen等等。Openstack</p><h2 id="_1-2-什么是docker" tabindex="-1"><a class="header-anchor" href="#_1-2-什么是docker" aria-hidden="true">#</a> 1.2 什么是Docker</h2><figure><img src="'+h+'" alt="1554250976402" tabindex="0" loading="lazy"><figcaption>1554250976402</figcaption></figure><h3 id="_1-2-1容器技术" tabindex="-1"><a class="header-anchor" href="#_1-2-1容器技术" aria-hidden="true">#</a> 1.2.1容器技术</h3><p>在计算机的世界中，容器拥有一段漫长且传奇的历史。容器与管理程序虚拟化（hypervisor virtualization，HV）有所不同，管理程序虚拟化通过中间层将一台或者多台独立的机器虚拟运行与物理硬件之上，而容器则是直接运行在操作系统内核之上的用户空间。因此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行在同一台宿主机上。</p><p>由于“客居”于操作系统，容器只能运行与底层宿主机相同或者相似的操作系统，这看起来并不是非常灵活。例如：可以在Ubuntu服务中运行Redhat Enterprise Linux，但无法再Ubuntu服务器上运行Microsoft Windows。</p><p>相对于彻底隔离的管理程序虚拟化，容器被认为是不安全的。而反对这一观点的人则认为，由于虚拟容器所虚拟的是一个完整的操作系统，这无疑增大了攻击范围，而且还要考虑管理程序层潜在的暴露风险。</p><p>尽管有诸多局限性，容器还是被广泛部署于各种各样的应用场合。在超大规模的多租户服务部署、轻量级沙盒以及对安全要求不太高的隔离环境中，容器技术非常流行。最常见的一个例子就是“权限隔离监牢”（chroot jail），它创建一个隔离的目录环境来运行进程。如果权限隔离监牢正在运行的进程被入侵者攻破，入侵者便会发现自己“身陷囹圄”，因为权限不足被困在容器所创建的目录中，无法对宿主机进一步破坏。</p><p>最新的容器技术引入了OpenVZ、Solaris Zones以及Linux容器（LXC）。使用这些新技术，容器不在仅仅是一个单纯的运行环境。在自己的权限类内，容器更像是一个完整的宿主机。对Docker来说，它得益于现代Linux特性，如控件组（control group）、命名空间（namespace）技术，容器和宿主机之间的隔离更加彻底，容器有独立的网络和存储栈，还拥有自己的资源管理能力，使得同一台宿主机中的多个容器可以友好的共存。</p><p>容器被认为是精益技术，因为容器需要的开销有限。和传统虚拟化以及半虚拟化相比，容器不需要模拟层（emulation layer）和管理层（hypervisor layer），而是使用操作系统的系统调用接口。这降低了运行单个容器所需的开销，也使得宿主机中可以运行更多的容器。</p><p>尽管有着光辉的历史，容器仍未得到广泛的认可。一个很重要的原因就是容器技术的复杂性：容器本身就比较复杂，不易安装，管理和自动化也很困难。而Docker就是为了改变这一切而生的。</p><h3 id="_1-2-2容器与虚拟机比较" tabindex="-1"><a class="header-anchor" href="#_1-2-2容器与虚拟机比较" aria-hidden="true">#</a> 1.2.2容器与虚拟机比较</h3><h4 id="_1-2-2-1-本质上的区别" tabindex="-1"><a class="header-anchor" href="#_1-2-2-1-本质上的区别" aria-hidden="true">#</a> 1.2.2.1 本质上的区别</h4><figure><img src="'+g+'" alt="1554251078724" tabindex="0" loading="lazy"><figcaption>1554251078724</figcaption></figure><h4 id="_1-2-2-2-使用上的区别" tabindex="-1"><a class="header-anchor" href="#_1-2-2-2-使用上的区别" aria-hidden="true">#</a> 1.2.2.2 使用上的区别</h4><figure><img src="'+m+'" alt="1554255070258" tabindex="0" loading="lazy"><figcaption>1554255070258</figcaption></figure><p>虚拟机已死，容器才是未来。</p><h3 id="_1-2-3-docker特点" tabindex="-1"><a class="header-anchor" href="#_1-2-3-docker特点" aria-hidden="true">#</a> 1.2.3 Docker特点</h3><h4 id="_1-2-3-1-上手快" tabindex="-1"><a class="header-anchor" href="#_1-2-3-1-上手快" aria-hidden="true">#</a> 1.2.3.1 上手快</h4><p>用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。</p><p>​ 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</p><h4 id="_1-2-3-2-职责的逻辑分离" tabindex="-1"><a class="header-anchor" href="#_1-2-3-2-职责的逻辑分离" aria-hidden="true">#</a> 1.2.3.2 职责的逻辑分离</h4><p>使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p><h4 id="_1-2-3-3-快速高效的开发生命周期" tabindex="-1"><a class="header-anchor" href="#_1-2-3-3-快速高效的开发生命周期" aria-hidden="true">#</a> 1.2.3.3 快速高效的开发生命周期</h4><p>Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p><h4 id="_1-2-3-4-鼓励使用面向服务的架构-soa" tabindex="-1"><a class="header-anchor" href="#_1-2-3-4-鼓励使用面向服务的架构-soa" aria-hidden="true">#</a> 1.2.3.4 鼓励使用面向服务的架构 SOA</h4><p>Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）</p><h2 id="_1-3-docker组件" tabindex="-1"><a class="header-anchor" href="#_1-3-docker组件" aria-hidden="true">#</a> 1.3 Docker组件</h2><h3 id="_1-3-1-docker客户端和服务器-c-s" tabindex="-1"><a class="header-anchor" href="#_1-3-1-docker客户端和服务器-c-s" aria-hidden="true">#</a> 1.3.1 Docker客户端和服务器 c/s</h3><p>Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p><figure><img src="'+v+'" alt="1554255252421" tabindex="0" loading="lazy"><figcaption>1554255252421</figcaption></figure><h3 id="_1-3-2-docker镜像-文件" tabindex="-1"><a class="header-anchor" href="#_1-3-2-docker镜像-文件" aria-hidden="true">#</a> 1.3.2 Docker镜像-文件</h3><p>镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如：</p><p>添加一个文件；</p><p>执行一个命令； boot程序。</p><p>打开一个窗口。</p><p>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</p><h3 id="_1-3-3-registry-注册中心" tabindex="-1"><a class="header-anchor" href="#_1-3-3-registry-注册中心" aria-hidden="true">#</a> 1.3.3 Registry（注册中心）</h3><p>Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。</p><h3 id="_1-3-4-docker容器" tabindex="-1"><a class="header-anchor" href="#_1-3-4-docker容器" aria-hidden="true">#</a> 1.3.4 Docker容器</h3><p>Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p><figure><img src="'+k+'" alt="1554268579991" tabindex="0" loading="lazy"><figcaption>1554268579991</figcaption></figure><p>所以Docker容器就是：</p><p>一个镜像格式；</p><p>一些列标准操作；</p><p>一个执行环境。</p><p>Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p><p>​ 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。</p><p>​ Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。</p><p>​ 使用Docker，我们可以快速的构建一个应用程序服务器、一个消息总线、一套实用工具、一个持续集成（CI）测试环境或者任意一种应用程序、服务或工具。我们可以在本地构建一个完整的测试环境，也可以为生产或开发快速复制一套复杂的应用程序栈。</p><h1 id="第2章-docker安装与启动" tabindex="-1"><a class="header-anchor" href="#第2章-docker安装与启动" aria-hidden="true">#</a> 第2章 Docker安装与启动</h1><h2 id="_2-1-安装环境说明" tabindex="-1"><a class="header-anchor" href="#_2-1-安装环境说明" aria-hidden="true">#</a> 2.1 安装环境说明</h2><p>Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p><p>由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x(宿主机)以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。</p><h2 id="_2-2-在vmware-workstation中安装centos7" tabindex="-1"><a class="header-anchor" href="#_2-2-在vmware-workstation中安装centos7" aria-hidden="true">#</a> 2.2 在VMware Workstation中安装CentOS7</h2><p>资料已经准备了安装好的镜像，直接挂载即可。</p><p>挂载后，使用ip addr命令查看本地IP</p><figure><img src="'+b+`" alt="1563846522694" tabindex="0" loading="lazy"><figcaption>1563846522694</figcaption></figure><p>账号：root</p><p>密码：123456</p><h2 id="_2-3-安装docker" tabindex="-1"><a class="header-anchor" href="#_2-3-安装docker" aria-hidden="true">#</a> 2.3 安装Docker</h2><p>使用yum命令在线安装</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">yum</span> <span class="token value attr-value">install docker</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+f+`" alt="1554268730431" tabindex="0" loading="lazy"><figcaption>1554268730431</figcaption></figure><h2 id="_2-4-安装后查看docker版本" tabindex="-1"><a class="header-anchor" href="#_2-4-安装后查看docker版本" aria-hidden="true">#</a> 2.4 安装后查看Docker版本</h2><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">-v</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+_+'" alt="1554268787279" tabindex="0" loading="lazy"><figcaption>1554268787279</figcaption></figure><h2 id="_2-5-启动与停止docker" tabindex="-1"><a class="header-anchor" href="#_2-5-启动与停止docker" aria-hidden="true">#</a> 2.5 启动与停止Docker</h2><p><strong>systemctl</strong>命令是系统服务管理器指令，它是 service 和 chkconfig 两个命令组合。</p><p>l 启动docker：systemctl start docker</p><p>l 停止docker：systemctl stop docker</p><p>l 重启docker：systemctl restart docker</p><p>l 查看docker状态：systemctl status docker</p><p>l 开机启动：systemctl enable docker</p><figure><img src="'+x+'" alt="1554268839313" tabindex="0" loading="lazy"><figcaption>1554268839313</figcaption></figure><p>l 查看docker概要信息：docker info</p><p>l 查看docker帮助文档：docker --help</p><h1 id="第3章-docker镜像操作" tabindex="-1"><a class="header-anchor" href="#第3章-docker镜像操作" aria-hidden="true">#</a> 第3章 Docker镜像操作</h1><h2 id="_3-1-什么是docker镜像" tabindex="-1"><a class="header-anchor" href="#_3-1-什么是docker镜像" aria-hidden="true">#</a> 3.1 什么是Docker镜像</h2><p>Docker镜像是由文件系统叠加而成（是一种文件的存储形式）。最底端是一个文件引导系统，即bootfs，这很像典型的Linux/Unix的引导文件系统。Docker用户几乎永远不会和引导系统有什么交互。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要的一些文件，而这些文件就可以称为Docker镜像。</p><figure><img src="'+y+'" alt="1554268883192" tabindex="0" loading="lazy"><figcaption>1554268883192</figcaption></figure><h2 id="_3-2-列出镜像" tabindex="-1"><a class="header-anchor" href="#_3-2-列出镜像" aria-hidden="true">#</a> 3.2 列出镜像</h2><p>列出docker下的所有镜像：docker images</p><figure><img src="'+D+'" alt="1554268977335" tabindex="0" loading="lazy"><figcaption>1554268977335</figcaption></figure><p>l REPOSITORY：镜像所在的仓库名称</p><p>l TAG：镜像标签</p><p>l IMAGE ID：镜像ID</p><p>l CREATED：镜像的创建日期（不是获取该镜像的日期）</p><p>l SIZE：镜像大小</p><p>l 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p><figure><img src="'+w+'" alt="1554269036684" tabindex="0" loading="lazy"><figcaption>1554269036684</figcaption></figure><p>为了区分同一个仓库下的不同镜像，Docker提供了一种称为标签（Tag）的功能。每个镜像在列出来时都带有一个标签，例如12.10、12.04等等。每个标签对组成特定镜像的一些镜像层进行标记（比如，标签12.04就是对所有Ubuntu12.04镜像层的标记）。这种机制使得同一个仓库中可以存储多个镜像。--- 版本号</p>',125),G={href:"http://docker.io/ubunto:12.04",target:"_blank",rel:"noopener noreferrer"},Z=i(`<h2 id="_3-3-搜索镜像" tabindex="-1"><a class="header-anchor" href="#_3-3-搜索镜像" aria-hidden="true">#</a> 3.3 搜索镜像</h2><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">search 镜像名称</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+S+'" alt="1554269087361" tabindex="0" loading="lazy"><figcaption>1554269087361</figcaption></figure><p>n NAME：仓库名称</p><p>n DESCRIPTION：镜像描述</p><p>n STARS：用户评价，反应一个镜像的受欢迎程度</p><p>n OFFICIAL：是否官方</p><p>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p><h2 id="_3-4-拉取镜像-获取镜像" tabindex="-1"><a class="header-anchor" href="#_3-4-拉取镜像-获取镜像" aria-hidden="true">#</a> 3.4 拉取镜像[获取镜像]</h2><h3 id="_3-4-1-从docker-hub拉取" tabindex="-1"><a class="header-anchor" href="#_3-4-1-从docker-hub拉取" aria-hidden="true">#</a> 3.4.1 从Docker Hub拉取</h3><p>Docker镜像首页，包括官方镜像和其它公开镜像。Docker Hub上最受欢迎的10大镜像（通过Docker registry API获取不了镜像被pull的个数，只能通过镜像的stars数量，来衡量镜像的流行度。毫无疑问，拥有最高stars数量的库都是官方库）。</p>',12),J={href:"https://hub.docker.com/search?image_filter=official&type=image",target:"_blank",rel:"noopener noreferrer"},K=e("figure",null,[e("img",{src:z,alt:"1554269473918",tabindex:"0",loading:"lazy"}),e("figcaption",null,"1554269473918")],-1),ee={href:"http://docker.io",target:"_blank",rel:"noopener noreferrer"},ae=i(`<p>Private Registry（私有仓库）是开发者或者企业自建的镜像存储库，通常用来保存企业内部的 Docker 镜像，用于内部开发流程和产品的发布、版本控制。</p><p>Mirror是一种代理中转服务，我们(比如daocloud)提供的Mirror服务，直接对接Docker Hub的官方Registry。Docker Hub 上有数以十万计的各类 Docker 镜像。</p><p>在使用Private Registry时，需要在Docker Pull 或Dockerfile中直接键入Private Registry 的地址，通常这样会导致与 Private Registry 的绑定，缺乏灵活性。</p><p>使用 Mirror 服务，只需要在 Docker 守护进程（Daemon）的配置文件中加入 Mirror 参数，即可在全局范围内透明的访问官方的 Docker Hub，避免了对 Dockerfile 镜像引用来源的修改。</p><p>简单来说，Mirror类似CDN，本质是官方的cache；Private Registry类似私服，跟官方没什么关系。对用户来说，由于用户是要拖docker hub上的image，对应的是Mirror。yum/apt-get的Mirror又有点不一样，它其实是把官方的库文件整个拖到自己的服务器上做镜像，并定时与官方做同步；而Docker Mirror只会缓存曾经使用过的image。</p><p>使用命令拉取：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker pull centos:7
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>目前国内访问docker hub速度上有点尴尬，使用docker Mirror势在必行。现有国内提供docker镜像加速服务的商家有不少，下面重点ustc镜像。</p><h3 id="_3-4-2-ustc的镜像" tabindex="-1"><a class="header-anchor" href="#_3-4-2-ustc的镜像" aria-hidden="true">#</a> 3.4.2 ustc的镜像</h3><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</p>`,10),se={href:"https://lug.ustc.edu.cn/wiki/mirrors/help/docker",target:"_blank",rel:"noopener noreferrer"},ne=i('<p><strong>步骤：</strong></p><p>（1）编辑该文件：vi /etc/docker/daemon.json // 如果该文件不存在就手动创建；说明：在centos7.x下，通过vi。</p><figure><img src="'+M+`" alt="1554269542721" tabindex="0" loading="lazy"><figcaption>1554269542721</figcaption></figure><p>（2）在该文件中输入如下内容：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>{
<span class="token key attr-name">	&quot;registry-mirrors&quot;</span><span class="token punctuation">:</span> <span class="token value attr-value">[&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span>
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）注意：一定要重启docker服务，如果重启docker后无法加速，可以重新启动OS</p><figure><img src="`+R+`" alt="1554269600589" tabindex="0" loading="lazy"><figcaption>1554269600589</figcaption></figure><p>然后通过docker pull命令下载镜像：速度杠杠的。</p><h2 id="_3-5-删除镜像" tabindex="-1"><a class="header-anchor" href="#_3-5-删除镜像" aria-hidden="true">#</a> 3.5 删除镜像</h2><p>1、 docker rmi $IMAGE_ID：删除指定镜像</p><p>2、 docker rmi <code>docker images -q</code>：删除所有镜像</p><h1 id="第4章-docker容器操作" tabindex="-1"><a class="header-anchor" href="#第4章-docker容器操作" aria-hidden="true">#</a> 第4章 Docker容器操作</h1><h2 id="_4-1-查看容器" tabindex="-1"><a class="header-anchor" href="#_4-1-查看容器" aria-hidden="true">#</a> 4.1 查看容器</h2><p>l 查看正在运行容器：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">ps</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>l 查看所有的容器（启动过的历史容器）：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">ps –a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+q+`" alt="1554269647203" tabindex="0" loading="lazy"><figcaption>1554269647203</figcaption></figure><p>l 查看最后一次运行的容器：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">ps –l</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>l 查看停止的容器</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">ps -f status=exited</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_4-2-创建与启动容器" tabindex="-1"><a class="header-anchor" href="#_4-2-创建与启动容器" aria-hidden="true">#</a> 4.2 创建与启动容器</h2><p>l 创建容器常用的参数说明：</p><p>l 创建容器命令：docker run</p><p>l -i：表示运行容器</p><p>l -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</p><p>l --name :为创建的容器命名。</p><p>l -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</p><p>l -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</p><p>l -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个－p做多个端口映射</p><h3 id="_4-1-1-交互式容器" tabindex="-1"><a class="header-anchor" href="#_4-1-1-交互式容器" aria-hidden="true">#</a> 4.1.1 交互式容器</h3><p>创建一个交互式容器并取名为mycentos</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-i</span> <span class="token parameter variable">-t</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c1 centos /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态</p><figure><img src="`+O+'" alt="1554269753673" tabindex="0" loading="lazy"><figcaption>1554269753673</figcaption></figure><p>使用exit命令 退出当前容器</p><figure><img src="'+I+'" alt="1554269801076" tabindex="0" loading="lazy"><figcaption>1554269801076</figcaption></figure><p>然后用ps -a 命令查看发现该容器也随之停止：</p><figure><img src="'+A+`" alt="1554269834652" tabindex="0" loading="lazy"><figcaption>1554269834652</figcaption></figure><h3 id="_4-1-2-守护式容器" tabindex="-1"><a class="header-anchor" href="#_4-1-2-守护式容器" aria-hidden="true">#</a> 4.1.2 守护式容器</h3><p>创建一个守护式容器：如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。命令如下（容器名称不能重复）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-i</span> <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c2 centos /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>l 登录守护式容器方式：</p><p>docker exec -it container_name (或者 container_id) /bin/bash（exit退出时，容器不会停止）</p><figure><img src="`+E+'" alt="1554269906669" tabindex="0" loading="lazy"><figcaption>1554269906669</figcaption></figure><h2 id="_4-3-停止与启动容器" tabindex="-1"><a class="header-anchor" href="#_4-3-停止与启动容器" aria-hidden="true">#</a> 4.3 停止与启动容器</h2><p>l 停止正在运行的容器：docker stop $CONTAINER_NAME/ID</p><figure><img src="'+P+'" alt="1554269949611" tabindex="0" loading="lazy"><figcaption>1554269949611</figcaption></figure><p>l 启动已运行过的容器：docker start $CONTAINER_NAME/ID</p><figure><img src="'+T+`" alt="1554269990586" tabindex="0" loading="lazy"><figcaption>1554269990586</figcaption></figure><h2 id="_4-4-文件拷贝" tabindex="-1"><a class="header-anchor" href="#_4-4-文件拷贝" aria-hidden="true">#</a> 4.4 文件拷贝</h2><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker cp 需要拷贝的文件或目录 容器名称:容器目录
例如：docker cp 1.txt c2:/root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以将文件从容器内拷贝出来</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker cp 容器名称:容器目录 需要拷贝的文件或目录
例如：docker cp c2:/root/2.txt /root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-5-目录挂载" tabindex="-1"><a class="header-anchor" href="#_4-5-目录挂载" aria-hidden="true">#</a> 4.5 目录挂载</h2><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。</p><p>创建容器 添加-v参数 后边为 宿主机目录:容器目录</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>/opt：宿主机目录
/usr/local/myhtml：容器的目录    映射

docker run -id --name=c4 -v /opt/:/usr/local/myhtml centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p><figure><img src="`+N+`" alt="1554270072434" tabindex="0" loading="lazy"><figcaption>1554270072434</figcaption></figure><p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 --privileged=true 来解决挂载的目录没有权限的问题</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code>
<span class="token key attr-name">docker</span> <span class="token value attr-value">run -id --privileged=true --name=c4 -v /opt/:/usr/local/myhtml centos</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-6-查看容器ip地址" tabindex="-1"><a class="header-anchor" href="#_4-6-查看容器ip地址" aria-hidden="true">#</a> 4.6 查看容器IP地址</h2><p>我们可以通过以下命令查看容器运行的各种数据</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker inspect mycentos2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也可以直接执行下面的命令直接输出IP地址</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker inspect --format=&#39;{{.NetworkSettings.IPAddress}}&#39; mycentos2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_4-7-删除容器" tabindex="-1"><a class="header-anchor" href="#_4-7-删除容器" aria-hidden="true">#</a> 4.7 删除容器</h2><p>l 删除指定的容器：docker rm $CONTAINER_ID/NAME</p><figure><img src="`+C+'" alt="1554270157882" tabindex="0" loading="lazy"><figcaption>1554270157882</figcaption></figure><p>注意，只能删除停止的容器</p><p>l 删除所有容器：docker rm $(docker ps -a -q)</p><figure><img src="'+L+`" alt="1554270195286" tabindex="0" loading="lazy"><figcaption>1554270195286</figcaption></figure><h1 id="第5章-部署应用" tabindex="-1"><a class="header-anchor" href="#第5章-部署应用" aria-hidden="true">#</a> 第5章 部署应用</h1><p>需求：springboot 第一天：程序打包 xxx.war ----&gt;部署到容器中。</p><ul><li>查看防火墙状态：firewall-cmd --state</li><li>关闭防火墙：systemctl stop firewalld.service</li><li>禁止firewall开机启动：systemctl disable firewalld.service</li></ul><h2 id="_5-1-mysql部署" tabindex="-1"><a class="header-anchor" href="#_5-1-mysql部署" aria-hidden="true">#</a> 5.1 MySQL部署</h2><h3 id="_5-1-1拉取mysql镜像" tabindex="-1"><a class="header-anchor" href="#_5-1-1拉取mysql镜像" aria-hidden="true">#</a> 5.1.1拉取MySQL镜像</h3><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">pull mysql</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+H+'" alt="1554275876795" tabindex="0" loading="lazy"><figcaption>1554275876795</figcaption></figure><p>查看镜像</p><figure><img src="'+V+`" alt="1554275938383" tabindex="0" loading="lazy"><figcaption>1554275938383</figcaption></figure><h3 id="_5-1-2-创建mysql容器" tabindex="-1"><a class="header-anchor" href="#_5-1-2-创建mysql容器" aria-hidden="true">#</a> 5.1.2 创建MySQL容器</h3><p>-p：端口映射。</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">run -di --name mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span>

<span class="token key attr-name">docker</span> <span class="token value attr-value">run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</p><p>-e 代表添加环境变量 MYSQL_ROOT_PASSWORD是root用户的登陆密码</p><h3 id="_5-1-3-进入mysql容器-登陆mysql" tabindex="-1"><a class="header-anchor" href="#_5-1-3-进入mysql容器-登陆mysql" aria-hidden="true">#</a> <strong>5.1.3 进入MySQL容器,登陆MySQL</strong></h3><p>进入mysql容器</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">exec -it mysql /bin/bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>登陆mysql</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">mysql</span> <span class="token value attr-value">-u root -p</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_5-1-4-远程登陆mysql" tabindex="-1"><a class="header-anchor" href="#_5-1-4-远程登陆mysql" aria-hidden="true">#</a> 5.1.4 远程登陆MySQL</h3><p>（1）我们在我们本机的电脑上去连接虚拟机Centos中的Docker容器，这里192.168.247.130是虚拟机操作系统的IP <img src="`+U+`" alt="1554276054400" loading="lazy"></p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>MySQL最新的版本：连不上。

# plugin非mysql_native_password 则需要修改密码   授权。
ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）在本地客户端执行建库脚本</p><p>执行“资源/建库语句/springboot.sql”</p><figure><img src="`+Q+`" alt="1564414004388" tabindex="0" loading="lazy"><figcaption>1564414004388</figcaption></figure><h3 id="_5-1-5-查看容器ip地址" tabindex="-1"><a class="header-anchor" href="#_5-1-5-查看容器ip地址" aria-hidden="true">#</a> 5.1.5 查看容器IP地址</h3><p>我们可以通过以下命令查看容器运行的各种数据</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker inspect mysql
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>运行效果如下：</p><figure><img src="`+j+`" alt="1554276119395" tabindex="0" loading="lazy"><figcaption>1554276119395</figcaption></figure><p>我们可以看到我们的数据库服务器的IP是172.17.0.5</p><h2 id="_5-2-tomcat部署" tabindex="-1"><a class="header-anchor" href="#_5-2-tomcat部署" aria-hidden="true">#</a> 5.2 tomcat部署</h2><h3 id="_5-2-1-拉取tomcat镜像" tabindex="-1"><a class="header-anchor" href="#_5-2-1-拉取tomcat镜像" aria-hidden="true">#</a> 5.2.1 拉取tomcat镜像</h3><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">pull docker.io/silentheartbeat/tomcat8-jre8</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_5-2-2-创建tomcat容器" tabindex="-1"><a class="header-anchor" href="#_5-2-2-创建tomcat容器" aria-hidden="true">#</a> 5.2.2 创建tomcat容器</h3><p>创建容器用于部署ssm集成项目 -p表示地址映射</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">run -di --name=tomcat -p 9000:8080 -v /usr/local/web:/usr/local/tomcat/webapps --privileged=true silentheartbeat/tomcat8-jre8</span>


<span class="token key attr-name">docker</span> <span class="token value attr-value">run -id -p 8080:8080 --name mytomcat -v /usr/local/web:/usr/local/tomcat/webapps --privileged=true tomcat:latest</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-2-3-部署web应用" tabindex="-1"><a class="header-anchor" href="#_5-2-3-部署web应用" aria-hidden="true">#</a> 5.2.3 部署web应用</h3><p>（1）修改ssm集成项目的配置文件，修改数据库连接的url</p><figure><img src="`+W+'" alt="1563838223200" tabindex="0" loading="lazy"><figcaption>1563838223200</figcaption></figure>',115),ie={href:"http://192.168.211.132:9000/user/findAll",target:"_blank",rel:"noopener noreferrer"},re=i('<p>PS：如果如法访问，进入tomcat容器并且启动tomcat。<img src="'+B+`" alt="1563838278876" loading="lazy"></p><h2 id="_5-3-nginx部署" tabindex="-1"><a class="header-anchor" href="#_5-3-nginx部署" aria-hidden="true">#</a> 5.3 Nginx部署</h2><h3 id="_5-3-1-拉取nginx镜像" tabindex="-1"><a class="header-anchor" href="#_5-3-1-拉取nginx镜像" aria-hidden="true">#</a> 5.3.1 拉取Nginx镜像</h3><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">pull nginx</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_5-3-2-创建nginx容器" tabindex="-1"><a class="header-anchor" href="#_5-3-2-创建nginx容器" aria-hidden="true">#</a> 5.3.2 创建Nginx容器</h3><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">run -id --name=nginx -p 80:80 docker.io/nginx</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_5-3-3-测试nginx" tabindex="-1"><a class="header-anchor" href="#_5-3-3-测试nginx" aria-hidden="true">#</a> 5.3.3 测试Nginx</h3>`,7),te={href:"http://192.168.211.132",target:"_blank",rel:"noopener noreferrer"},de=i('<figure><img src="'+Y+`" alt="1563838515415" tabindex="0" loading="lazy"><figcaption>1563838515415</figcaption></figure><h3 id="_5-3-4-配置反向代理" tabindex="-1"><a class="header-anchor" href="#_5-3-4-配置反向代理" aria-hidden="true">#</a> 5.3.4 配置反向代理</h3><p>官方的nginx镜像,nginx配置文件nginx.conf 在/etc/nginx/目录下。</p><p>在容器内编辑配置文件不方便，我\`们可以先将配置文件从容器内拷贝到宿主机，编辑修改后再拷贝回去。</p><p>（1）从容器拷贝配置文件到宿主机</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">cp nginx:/etc/nginx/nginx.conf nginx.conf</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（2）编辑nginx.conf，添加反向代理配置</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">upstream</span> <span class="token value attr-value">tomcat-ssm {</span>
<span class="token key attr-name">        server</span> <span class="token value attr-value">172.17.0.3:8080;</span>
}
<span class="token key attr-name">server</span> <span class="token value attr-value">{</span>
<span class="token key attr-name">        listen</span> <span class="token value attr-value">80;</span>
<span class="token key attr-name">        server_name</span> <span class="token value attr-value">www.ssm.com;</span>
<span class="token key attr-name">        location</span> <span class="token value attr-value">/ {</span>
<span class="token key attr-name">                proxy_pass</span> <span class="token value attr-value">http://tomcat-ssm;</span>
<span class="token key attr-name">                index</span> <span class="token value attr-value">index.html index.htm;</span>
        }
}


<span class="token key attr-name">upstream</span> <span class="token value attr-value">springboot_demo4_jpa-0.0.1-SNAPSHOT {</span>
<span class="token key attr-name">        server</span> <span class="token value attr-value">172.17.0.2:8080;</span>
}
<span class="token key attr-name">server</span> <span class="token value attr-value">{</span>
<span class="token key attr-name">        listen</span> <span class="token value attr-value">80;</span>
<span class="token key attr-name">        server_name</span> <span class="token value attr-value">www.ssm.com;</span>
<span class="token key attr-name">        location</span> <span class="token value attr-value">/ {</span>
<span class="token key attr-name">                proxy_pass</span> <span class="token value attr-value">http://springboot_demo4_jpa-0.0.1-SNAPSHOT;</span>
<span class="token key attr-name">                index</span> <span class="token value attr-value">index.html index.htm;</span>
        }
}


<span class="token key attr-name">upstream</span> <span class="token value attr-value">ssm {</span>
<span class="token key attr-name">        server</span> <span class="token value attr-value">172.17.0.5:8080;</span>
}
<span class="token key attr-name">server</span> <span class="token value attr-value">{</span>
<span class="token key attr-name">        listen</span> <span class="token value attr-value">80;</span>
<span class="token key attr-name">        server_name</span> <span class="token value attr-value">www.ssm.com;</span>
<span class="token key attr-name">        location</span> <span class="token value attr-value">/ {</span>
<span class="token key attr-name">                proxy_pass</span> <span class="token value attr-value">http://ssm/springboot_demo4_jpa-0.0.1-SNAPSHOT/user/findUsers;</span>
<span class="token key attr-name">                index</span> <span class="token value attr-value">index.html index.htm;</span>
        }
}

<span class="token key attr-name">http</span><span class="token punctuation">:</span><span class="token value attr-value">//www.ssm.com/user/findUsers</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）将修改后的配置文件拷贝到容器</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">cp nginx.conf  nginx:/etc/nginx/nginx.conf</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（4）重新启动容器</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">docker</span> <span class="token value attr-value">restart nginx</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（5）设置域名指向</p><p>修改<code>C:/Windows/System32/drivers/etc/hosts</code>文件，添加如下：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">192.168.211.132</span> <span class="token value attr-value">www.ssm.com</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,15),le={href:"http://www.ssm.com/user/findAll",target:"_blank",rel:"noopener noreferrer"},ce=i('<figure><img src="'+$+`" alt="1563838882452" tabindex="0" loading="lazy"><figcaption>1563838882452</figcaption></figure><p>提示：如果不支持vim指令，则可以下载更新安装</p><p>apt-get <strong>update</strong></p><p>apt-get install vim</p><h2 id="_5-4-redis部署" tabindex="-1"><a class="header-anchor" href="#_5-4-redis部署" aria-hidden="true">#</a> 5.4 Redis部署</h2><h3 id="_5-4-1-拉取redis镜像" tabindex="-1"><a class="header-anchor" href="#_5-4-1-拉取redis镜像" aria-hidden="true">#</a> 5.4.1 拉取Redis镜像</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker pull redis
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_5-4-2-创建redis容器" tabindex="-1"><a class="header-anchor" href="#_5-4-2-创建redis容器" aria-hidden="true">#</a> 5.4.2 创建Redis容器</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker run -di --name=redis -p 6379:6379 redis
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_5-4-3-客户端测试" tabindex="-1"><a class="header-anchor" href="#_5-4-3-客户端测试" aria-hidden="true">#</a> 5.4.3 客户端测试</h3><p>在你的本地电脑命令提示符下，用window版本redis测试</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>redis-cli -h 192.168.247.135
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="第6章-备份与迁移" tabindex="-1"><a class="header-anchor" href="#第6章-备份与迁移" aria-hidden="true">#</a> 第6章 备份与迁移</h1><h2 id="_6-1-容器保存为镜像" tabindex="-1"><a class="header-anchor" href="#_6-1-容器保存为镜像" aria-hidden="true">#</a> 6.1 容器保存为镜像</h2><p>我们可以通过以下命令将容器保存为镜像</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>nginx容器：配置配好了。        服务器：nginx容器。
docker commit nginx mynginx		 将容器提交为一个新的镜像
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>nginx是容器名称</p><p>mynginx是新的镜像名称</p><p>此镜像的内容就是你当前容器的内容，接下来你可以用此镜像再次运行新的容器</p><h2 id="_6-2-镜像备份" tabindex="-1"><a class="header-anchor" href="#_6-2-镜像备份" aria-hidden="true">#</a> 6.2 镜像备份</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker  save -o mynginx.tar mynginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>-o 输出到的文件</p><p>执行后，运行ls命令即可看到打成的tar包</p><h2 id="_6-3-镜像恢复与迁移" tabindex="-1"><a class="header-anchor" href="#_6-3-镜像恢复与迁移" aria-hidden="true">#</a> 6.3 镜像恢复与迁移</h2><p>首先我们先删除掉mynginx镜像</p><p>然后执行此命令进行恢复</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker load -i mynginx.tar
docker load -i fastdfs.tar
cat fastdfs.tar | sudo docker import - morunchang/fastdfs
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>-i 输入的文件</p><p>执行后再次查看镜像，可以看到镜像已经恢复</p>`,29);function pe(oe,ue){const s=t("ExternalLinkIcon");return d(),l("div",null,[F,e("p",null,[a("​ 我们在运行同一个仓库中的不同镜像时，可以通过在仓库名后面加上一个冒号和标签名来指定该仓库中的某一具体的镜像，例如docker run --name custom_container_name –i –t "),e("a",G,[a("docker.io/ubunto:12.04"),n(s)]),a(" /bin/bash，表明从镜像Ubuntu:12.04启动一个容器，而这个镜像的操作系统就是Ubuntu:12.04。在构建容器时指定仓库的标签也是一个好习惯。")]),Z,e("p",null,[e("a",J,[a("https://hub.docker.com/search?image_filter=official&type=image"),n(s)])]),K,e("p",null,[a("国情的原因，国内下载 Docker HUB 官方的相关镜像比较慢，可以使用国内（"),e("a",ee,[a("docker.io"),n(s)]),a("）的一些镜像加速器，镜像保持和官方一致，关键是速度块，推荐使用。Mirror与Private Registry的区别：")]),ae,e("p",null,[e("a",se,[a("https://lug.ustc.edu.cn/wiki/mirrors/help/docker"),n(s)])]),ne,e("p",null,[a("测试：地址栏输入："),e("a",ie,[a("http://192.168.211.132:9000/user/findAll"),n(s)])]),re,e("p",null,[a("浏览器地址栏输入： "),e("a",te,[a("http://192.168.211.132"),n(s)])]),de,e("p",null,[a("浏览器测试："),e("a",le,[a("http://www.ssm.com/user/findAll"),n(s)])]),ce])}const me=r(X,[["render",pe],["__file","docker-v1-01.html.vue"]]);export{me as default};
