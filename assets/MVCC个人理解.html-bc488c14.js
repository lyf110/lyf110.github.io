import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as d,c as r,e}from"./app-5f6064b2.js";const a="/assets/202302281826444-71d9aba5.png",i="/assets/202302281826813-6133893d.png",n="/assets/202302281826911-746f58d1.png",o="/assets/202210150907796-23ee3c4d.jpeg",h={},_=e('<h1 id="mvcc理解" tabindex="-1"><a class="header-anchor" href="#mvcc理解" aria-hidden="true">#</a> MVCC理解</h1><h2 id="_1-基本概念" tabindex="-1"><a class="header-anchor" href="#_1-基本概念" aria-hidden="true">#</a> 1 基本概念</h2><h3 id="_1-1-当前读" tabindex="-1"><a class="header-anchor" href="#_1-1-当前读" aria-hidden="true">#</a> 1.1 当前读</h3><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ... for update、update、insert、delete(排他锁)都是一种当前读。</p><h3 id="_1-2-快照读" tabindex="-1"><a class="header-anchor" href="#_1-2-快照读" aria-hidden="true">#</a> 1.2 快照读</h3><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul><h3 id="_1-3-mvcc" tabindex="-1"><a class="header-anchor" href="#_1-3-mvcc" aria-hidden="true">#</a> 1.3 MVCC</h3><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，时代读写操作没有冲突，快照读为MySQL实现了一个非阻塞读取功能。MVCC的具体实现，需要依赖于数据库记录中的三个隐藏字段、undo log日志、readview</p><h4 id="_1-3-1-三个隐藏字段" tabindex="-1"><a class="header-anchor" href="#_1-3-1-三个隐藏字段" aria-hidden="true">#</a> 1.3.1 三个隐藏字段</h4><table><thead><tr><th><strong>隐藏字段</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><h4 id="_1-3-2-undolog" tabindex="-1"><a class="header-anchor" href="#_1-3-2-undolog" aria-hidden="true">#</a> 1.3.2 undolog</h4><h5 id="_1-3-2-1-简介" tabindex="-1"><a class="header-anchor" href="#_1-3-2-1-简介" aria-hidden="true">#</a> 1.3.2.1 简介</h5><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p><h5 id="_1-3-2-2-版本链" tabindex="-1"><a class="header-anchor" href="#_1-3-2-2-版本链" aria-hidden="true">#</a> 1.3.2.2 版本链</h5><figure><img src="'+a+'" alt="image-20230228174748501" tabindex="0" loading="lazy"><figcaption>image-20230228174748501</figcaption></figure><blockquote><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p></blockquote><h3 id="_1-4-readview" tabindex="-1"><a class="header-anchor" href="#_1-4-readview" aria-hidden="true">#</a> 1.4 readview</h3><p>ReadView（读视图）是快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p><strong>ReadView的四个核心字段</strong></p><table><thead><tr><th><strong>字段</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p><strong>ReadView的访问规则</strong></p><p>trx_id 代表当前undolog版本链对应事务ID。</p><table><thead><tr><th><strong>条件</strong></th><th><strong>是否可以访问</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据是当前这个事务更改的。</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明数据已经提交了。</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>可以访问该版本</td><td>成立，说明该事务是在 ReadView生成后才开启。</td></tr><tr><td>trx_id not in m_ids</td><td>如果trx_id不在m_ids中，是可以访问该版本的</td><td>成立，说明数据已经提交。</td></tr></tbody></table><blockquote><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul></blockquote><h2 id="_2-rc级别-mvcc的做法" tabindex="-1"><a class="header-anchor" href="#_2-rc级别-mvcc的做法" aria-hidden="true">#</a> 2 RC级别 MVCC的做法</h2><figure><img src="'+i+'" alt="image-20230228174121466" tabindex="0" loading="lazy"><figcaption>image-20230228174121466</figcaption></figure><h3 id="_2-1-事务5第一次读取id为1的记录" tabindex="-1"><a class="header-anchor" href="#_2-1-事务5第一次读取id为1的记录" aria-hidden="true">#</a> 2.1 事务5第一次读取id为1的记录</h3><p>当前活跃的事务id是{3,4,5}，最小的事务id是3，最大的事务id是6，当前ReadView的创建事务Id是5，根据ReadView的访问规则，会先匹配undo log版本链的头，一直到匹配上为止</p><p><strong>匹配DB_TRX_ID为4的版本</strong></p><table><thead><tr><th><strong>条件</strong></th><th><strong>比较</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>4 == 5</td><td>不成立</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>4 &lt; 3</td><td>不成立</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>4 &gt; 6</td><td>不成立</td></tr><tr><td>trx_id not in m_ids</td><td>4 在{3,4,5}中</td><td>不成立</td></tr></tbody></table><p><strong>匹配DB_TRX_ID为3的版本</strong></p><table><thead><tr><th><strong>条件</strong></th><th><strong>比较</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>3 == 5</td><td>不成立</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>3 &lt; 3</td><td>不成立</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>3 &gt; 6</td><td>不成立</td></tr><tr><td>trx_id not in m_ids</td><td>3 在{3,4,5}中</td><td>不成立</td></tr></tbody></table><p><strong>匹配DB_TRX_ID为2的版本</strong></p><table><thead><tr><th><strong>条件</strong></th><th><strong>比较</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>2 == 5</td><td>不成立</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>2 &lt; 3</td><td>成立</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>2 &gt; 6</td><td>不成立</td></tr><tr><td>trx_id not in m_ids</td><td>2 不在{3,4,5}中</td><td>成立</td></tr></tbody></table><h4 id="_2-1-1-结果" tabindex="-1"><a class="header-anchor" href="#_2-1-1-结果" aria-hidden="true">#</a> 2.1.1 结果</h4><p>所以DB_TRX_ID为2的版本对应的数据就是我们要找的</p><h3 id="_2-2-事务5中第二次读取id为1的记录" tabindex="-1"><a class="header-anchor" href="#_2-2-事务5中第二次读取id为1的记录" aria-hidden="true">#</a> 2.2 事务5中第二次读取id为1的记录</h3><p>当前活跃的事务id是{4,5}，最小的事务id是4，最大的事务id是6，当前ReadView的创建事务Id是5，根据ReadView的访问规则，会先匹配undo log版本链的头，一直到匹配上为止</p><p><strong>匹配DB_TRX_ID为4的版本</strong></p><table><thead><tr><th><strong>条件</strong></th><th><strong>比较</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>4 == 5</td><td>不成立</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>4 &lt; 4</td><td>不成立</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>4 &gt; 6</td><td>不成立</td></tr><tr><td>trx_id not in m_ids</td><td>4 在{3,4,5}中</td><td>不成立</td></tr></tbody></table><p><strong>匹配DB_TRX_ID为3的版本</strong></p><table><thead><tr><th><strong>条件</strong></th><th><strong>比较</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>3 == 5</td><td>不成立</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>3 &lt; 4</td><td>成立</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>3 &gt; 6</td><td>不成立</td></tr><tr><td>trx_id not in m_ids</td><td>3 在{3,4,5}中</td><td>不成立</td></tr></tbody></table><h4 id="_2-2-1-结果" tabindex="-1"><a class="header-anchor" href="#_2-2-1-结果" aria-hidden="true">#</a> 2.2.1 结果</h4><p>DB_TRX_ID为3的版本对应数据就是我们需要的数据</p><h2 id="_3-rr级别下-mvcc的做法" tabindex="-1"><a class="header-anchor" href="#_3-rr级别下-mvcc的做法" aria-hidden="true">#</a> 3 RR级别下 MVCC的做法</h2><figure><img src="'+n+'" alt="image-20230228180700116" tabindex="0" loading="lazy"><figcaption>image-20230228180700116</figcaption></figure><h3 id="_3-1-结果" tabindex="-1"><a class="header-anchor" href="#_3-1-结果" aria-hidden="true">#</a> 3.1 结果</h3><p>在RR级别下，只有第一次快照读才会生成ReadView，所以每次读取的结果都是DB_TRX_ID为2的版本对应的数据</p><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4 总结</h2><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',53),s=[_];function g(l,c){return d(),r("div",null,s)}const b=t(h,[["render",g],["__file","MVCC个人理解.html.vue"]]);export{b as default};
