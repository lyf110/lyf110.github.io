import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as a,e}from"./app-5f6064b2.js";const p="/assets/202210122025513-142d5a56.jpeg",t="/assets/202210122028711-e1226893.jpeg",o="/assets/202210122029663-4d7a745d.jpeg",i="/assets/202210122030882-f5d270a4.jpeg",c="/assets/202210122031860-a12f6aac.jpeg",l="/assets/202210122031654-143ffcfd.jpeg",r="/assets/202210122031421-0cd50514.jpeg",d="/assets/202210122031730-9eca54ab.jpeg",u="/assets/202210122032547-252e345d.jpeg",k="/assets/202210122032706-ca4ace3e.jpeg",g="/assets/202210122032575-14e3a26f.jpeg",b="/assets/202210122033537-c0be2e12.jpeg",m="/assets/202210122033591-9645eb83.jpeg",h="/assets/202210122034406-abfbc91e.jpeg",f="/assets/202210122034156-d6866b28.jpeg",y="/assets/202210122034755-7794e9a6.jpeg",_="/assets/202210122121937-2189bbfb.png",v="/assets/202210122122842-6bcec012.jpeg",w="/assets/202210122122031-7661aadb.jpeg",x="/assets/202210122122942-b7b59fd2.jpeg",q="/assets/202210122122440-c1e769d9.jpeg",z="/assets/202210122124276-9ba31848.png",j="/assets/202210122131408-4de12019.jpeg",L="/assets/202210122134453-8e86dd88.jpeg",E="/assets/202210122134578-836e0a92.jpeg",U="/assets/202210122138261-b07dfa87.jpeg",S="/assets/202210122138119-928c5160.jpeg",A="/assets/202210122142861-45d97af3.jpeg",I="/assets/202210122143009-66b5826f.jpeg",N="/assets/202210122144707-425c666e.jpeg",T="/assets/202210122145643-1b1169cd.jpeg",B="/assets/202210122148960-3fd3af6e.jpeg",D="/assets/202210122149643-913095b2.jpeg",R="/assets/202210122149572-edadb84d.png",C="/assets/202210122149060-add21941.png",M="/assets/202210122153245-4b8b11b7.jpeg",Q="/assets/202210122154519-72d406bf.jpeg",O="/assets/202210122156209-7ddb844a.jpeg",H="/assets/202210122158296-1546451a.jpeg",F="/assets/202210122158230-309a5453.jpeg",J="/assets/202210122202464-69fc9389.jpeg",P={},V=e(`<h1 id="_3-sql优化" tabindex="-1"><a class="header-anchor" href="#_3-sql优化" aria-hidden="true">#</a> 3. SQL优化</h1><h2 id="_3-1-插入数据" tabindex="-1"><a class="header-anchor" href="#_3-1-插入数据" aria-hidden="true">#</a> 3.1 插入数据</h2><h3 id="_3-1-1-insert" tabindex="-1"><a class="header-anchor" href="#_3-1-1-insert" aria-hidden="true">#</a> 3.1.1 insert</h3><p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&#39;cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&#39;jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-优化方案一" tabindex="-1"><a class="header-anchor" href="#_1-优化方案一" aria-hidden="true">#</a> 1). 优化方案一</h4><p>批量插入数据</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">Insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_2-优化方案二" tabindex="-1"><a class="header-anchor" href="#_2-优化方案二" aria-hidden="true">#</a> 2). 优化方案二</h4><p>手动控制事务</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">&#39;Tom&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">&#39;Jerry&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-优化方案三" tabindex="-1"><a class="header-anchor" href="#_3-优化方案三" aria-hidden="true">#</a> 3). 优化方案三</h4><p>主键顺序插入，性能要高于乱序插入。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>主键乱序插入 : <span class="token number">8</span> <span class="token number">1</span> <span class="token number">9</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">15</span> <span class="token number">89</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">3</span>
主键顺序插入 : <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">15</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">89</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-1-2-大批量插入数据" tabindex="-1"><a class="header-anchor" href="#_3-1-2-大批量插入数据" aria-hidden="true">#</a> 3.1.2 大批量插入数据</h3><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使 用MySQL数据库提供的load指令进行插入。操作如下：</p><figure><img src="`+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 客户端连接服务端时，加上参数 -–local-infile</span>
mysql –<span class="token operator">-</span><span class="token keyword">local</span><span class="token operator">-</span><span class="token keyword">infile</span> <span class="token operator">-</span>u root <span class="token operator">-</span>p
<span class="token comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span>
<span class="token keyword">set</span> <span class="token keyword">global</span> local_infile <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">-- 执行load指令将准备好的数据，加载到表结构中</span>
<span class="token keyword">load</span> <span class="token keyword">data</span> <span class="token keyword">local</span> <span class="token keyword">infile</span> <span class="token string">&#39;/root/sql1.log&#39;</span> <span class="token keyword">into</span> <span class="token keyword">table</span> tb_user <span class="token keyword">fields</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">&#39;,&#39;</span> <span class="token keyword">lines</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">&#39;\\n&#39;</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>主键顺序插入性能高于乱序插入</p></blockquote><h4 id="_3-1-2-1-示例演示" tabindex="-1"><a class="header-anchor" href="#_3-1-2-1-示例演示" aria-hidden="true">#</a> 3.1.2.1 示例演示:</h4><h5 id="a-创建表结构" tabindex="-1"><a class="header-anchor" href="#a-创建表结构" aria-hidden="true">#</a> A. 创建表结构</h5><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>tb_user<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>
    <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">\`</span>username<span class="token punctuation">\`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">\`</span>password<span class="token punctuation">\`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">\`</span>name<span class="token punctuation">\`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">\`</span>birthday<span class="token punctuation">\`</span></span> <span class="token keyword">DATE</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">\`</span>sex<span class="token punctuation">\`</span></span> <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>unique_user_username<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>username<span class="token punctuation">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="b-设置参数" tabindex="-1"><a class="header-anchor" href="#b-设置参数" aria-hidden="true">#</a> B. 设置参数</h5><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 客户端连接服务端时，加上参数 -–local-infile</span>
mysql –<span class="token operator">-</span><span class="token keyword">local</span><span class="token operator">-</span><span class="token keyword">infile</span> <span class="token operator">-</span>u root <span class="token operator">-</span>p

<span class="token comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span>
<span class="token keyword">set</span> <span class="token keyword">global</span> local_infile <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="c-load加载数据" tabindex="-1"><a class="header-anchor" href="#c-load加载数据" aria-hidden="true">#</a> C. load加载数据</h5><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">load</span> <span class="token keyword">data</span> <span class="token keyword">local</span> <span class="token keyword">infile</span> <span class="token string">&#39;/root/load_user_100w_sort.sql&#39;</span> <span class="token keyword">into</span> <span class="token keyword">table</span> tb_user <span class="token keyword">fields</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">&#39;,&#39;</span> <span class="token keyword">lines</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">&#39;\\n&#39;</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们看到，插入100w的记录，17s就完成了，性能很好。</p><blockquote><p>在load时，主键顺序插入性能高于乱序插入</p></blockquote><h2 id="_3-2-主键优化" tabindex="-1"><a class="header-anchor" href="#_3-2-主键优化" aria-hidden="true">#</a> 3.2 主键优化</h2><p>在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的原因，然后再分析一下主键又该如何设计。</p><h3 id="_3-2-1-数据组织方式" tabindex="-1"><a class="header-anchor" href="#_3-2-1-数据组织方式" aria-hidden="true">#</a> 3.2.1 数据组织方式</h3><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不下，将会存储 到下一个页中，页与页之间会通过指针连接。</p><h3 id="_3-2-2-页分裂" tabindex="-1"><a class="header-anchor" href="#_3-2-2-页分裂" aria-hidden="true">#</a> 3.2.2 页分裂</h3><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p><h4 id="a-主键顺序插入效果" tabindex="-1"><a class="header-anchor" href="#a-主键顺序插入效果" aria-hidden="true">#</a> A. 主键顺序插入效果</h4><p>①. 从磁盘中申请页， 主键顺序插入</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>②. 第一个页没有满，继续往第一页插入</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>③. 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>④. 当第二页写满了，再往第三页写入</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="b-主键乱序插入效果" tabindex="-1"><a class="header-anchor" href="#b-主键乱序插入效果" aria-hidden="true">#</a> B. 主键乱序插入效果</h4><p>①. 加入1#,2#页都已经写满了，存放了如图所示的数据</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>②. 此时再插入id为50的记录，我们来看看会发生什么现象 会再次开启一个页，写入新的页中吗？</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个 页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上述的这种现象，称之为 &quot;页分裂&quot;，是比较耗费性能的操作。</p><h3 id="_3-2-3-页合并" tabindex="-1"><a class="header-anchor" href="#_3-2-3-页合并" aria-hidden="true">#</a> 3.2.3 页合并</h3><p>目前表中已有数据的索引结构(叶子节点)如下：</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当我们对已有数据进行删除时，具体的效果如下:</p><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当我们继续删除2#的数据记录</p><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</p><figure><img src="'+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个里面所发生的合并页的这个现象，就称之为 &quot;页合并&quot;。</p><blockquote><p>知识小贴士：<br> MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p></blockquote><h3 id="_3-2-4-索引设计原则" tabindex="-1"><a class="header-anchor" href="#_3-2-4-索引设计原则" aria-hidden="true">#</a> 3.2.4 索引设计原则</h3><ul><li><p>满足业务需求的情况下，尽量降低主键的长度。</p></li><li><p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</p></li><li><p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p></li><li><p>业务操作时，避免对主键的修改。</p></li></ul><figure><img src="'+z+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_3-3-order-by优化" tabindex="-1"><a class="header-anchor" href="#_3-3-order-by优化" aria-hidden="true">#</a> 3.3 order by优化</h2><p>MySQL的排序，有两种方式：</p><p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。</p><p>接下来，我们来做一个测试：</p><h3 id="_3-3-1-数据准备" tabindex="-1"><a class="header-anchor" href="#_3-3-1-数据准备" aria-hidden="true">#</a> 3.3.1 数据准备</h3><p>把之前测试时，为tb_user表所建立的部分索引直接删除掉</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">index</span> idx_user_phone <span class="token keyword">on</span> tb_user<span class="token punctuation">;</span>
<span class="token keyword">drop</span> <span class="token keyword">index</span> idx_user_phone_name <span class="token keyword">on</span> tb_user<span class="token punctuation">;</span>
<span class="token keyword">drop</span> <span class="token keyword">index</span> idx_user_name <span class="token keyword">on</span> tb_user<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+j+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-3-2-执行排序sql" tabindex="-1"><a class="header-anchor" href="#_3-3-2-执行排序sql" aria-hidden="true">#</a> 3.3.2 执行排序SQL</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+L+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age<span class="token punctuation">,</span> phone <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+E+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由于 age, phone 都没有索引，所以此时再排序时，出现Using filesort， 排序性能较低。</p><h3 id="_3-3-3-创建索引" tabindex="-1"><a class="header-anchor" href="#_3-3-3-创建索引" aria-hidden="true">#</a> 3.3.3 创建索引</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 创建索引</span>
<span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_age_phone_aa <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>age<span class="token punctuation">,</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-4-创建索引后-根据age-phone进行升序排序" tabindex="-1"><a class="header-anchor" href="#_3-3-4-创建索引后-根据age-phone进行升序排序" aria-hidden="true">#</a> 3.3.4 创建索引后，根据age, phone进行升序排序</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+U+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age<span class="token punctuation">,</span> phone<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+S+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能就是比较高的了。</p><h3 id="_3-3-5-创建索引后-根据age-phone进行降序排序" tabindex="-1"><a class="header-anchor" href="#_3-3-5-创建索引后-根据age-phone进行降序排序" aria-hidden="true">#</a> 3.3.5 创建索引后，根据age, phone进行降序排序</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span> age<span class="token punctuation">,</span> phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token keyword">desc</span><span class="token punctuation">,</span> phone <span class="token keyword">desc</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>也出现 Using index， 但是此时Extra中出现了 <code>Backward index scan</code>，这个<strong>代表反向扫描索引</strong>，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 <code>Backward index scan</code>。 在 MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p><h3 id="_3-3-6-根据phone-age进行升序排序-phone在前-age在后。" tabindex="-1"><a class="header-anchor" href="#_3-3-6-根据phone-age进行升序排序-phone在前-age在后。" aria-hidden="true">#</a> 3.3.6 根据phone，age进行升序排序，phone在前，age在后。</h3><figure><img src="'+I+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age是第一个字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p><h3 id="_3-3-7-根据age-phone进行降序一个升序-一个降序" tabindex="-1"><a class="header-anchor" href="#_3-3-7-根据age-phone进行降序一个升序-一个降序" aria-hidden="true">#</a> 3.3.7 根据age, phone进行降序一个升序，一个降序</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token keyword">asc</span> <span class="token punctuation">,</span> phone <span class="token keyword">desc</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+N+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时就会出现Using filesort。</p><figure><img src="'+T+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为了解决上述的问题，我们可以创建一个索引，这个联合索引中 age 升序排序，phone 倒序排序。</p><h3 id="_3-3-8-创建联合索引-age-升序排序-phone-倒序排序" tabindex="-1"><a class="header-anchor" href="#_3-3-8-创建联合索引-age-升序排序-phone-倒序排序" aria-hidden="true">#</a> 3.3.8 创建联合索引(age 升序排序，phone 倒序排序)</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_age_phone_ad <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>age <span class="token keyword">asc</span> <span class="token punctuation">,</span>phone <span class="token keyword">desc</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+B+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-3-9-然后再次执行如下sql" tabindex="-1"><a class="header-anchor" href="#_3-3-9-然后再次执行如下sql" aria-hidden="true">#</a> 3.3.9 然后再次执行如下SQL</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age<span class="token punctuation">,</span>phone <span class="token keyword">from</span> tb_user <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token keyword">asc</span> <span class="token punctuation">,</span> phone <span class="token keyword">desc</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+D+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>升序/降序联合索引结构图示:</p><figure><img src="'+R+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+C+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-3-10-order-by-优化原则" tabindex="-1"><a class="header-anchor" href="#_3-3-10-order-by-优化原则" aria-hidden="true">#</a> 3.3.10 order by 优化原则</h3><p>由上述的测试,我们得出order by优化原则:</p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。</p><p>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p><p>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</p><h2 id="_3-4-group-by优化" tabindex="-1"><a class="header-anchor" href="#_3-4-group-by优化" aria-hidden="true">#</a> 3.4 group by优化</h2><p>分组操作，我们主要来看看索引对于分组操作的影响。</p><p>首先我们先将 tb_user 表的索引全部删除掉 。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">index</span> idx_user_pro_age_sta <span class="token keyword">on</span> tb_user<span class="token punctuation">;</span>
<span class="token keyword">drop</span> <span class="token keyword">index</span> idx_email_5 <span class="token keyword">on</span> tb_user<span class="token punctuation">;</span>
<span class="token keyword">drop</span> <span class="token keyword">index</span> idx_user_age_phone_aa <span class="token keyword">on</span> tb_user<span class="token punctuation">;</span>
<span class="token keyword">drop</span> <span class="token keyword">index</span> idx_user_age_phone_ad <span class="token keyword">on</span> tb_user<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+M+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接下来，在没有索引的情况下，执行如下SQL，查询执行计划：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> profession <span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token keyword">group</span> <span class="token keyword">by</span> profession <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+Q+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后，我们在针对于 profession ， age， status 创建一个联合索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_pro_age_sta <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>profession<span class="token punctuation">,</span> age <span class="token punctuation">,</span> <span class="token keyword">status</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>紧接着，再执行前面相同的SQL查看执行计划。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> profession <span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token keyword">group</span> <span class="token keyword">by</span> profession <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+O+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>再执行如下的分组查询SQL，查看执行计划：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> profession<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> tb_user <span class="token keyword">group</span> <span class="token keyword">by</span> profession<span class="token punctuation">,</span> age<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+H+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> age<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token keyword">group</span> <span class="token keyword">by</span> age<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们发现，如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据 profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作， 在联合索引中，也是符合最左前缀法则的。</p><h3 id="_3-4-1-group-by-优化总结" tabindex="-1"><a class="header-anchor" href="#_3-4-1-group-by-优化总结" aria-hidden="true">#</a> 3.4.1 group by 优化总结</h3><p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p><p>A. 在分组操作时，可以通过索引来提高效率。</p><p>B. 分组操作时，索引的使用也是满足最左前缀法则的。</p><h2 id="_3-5-limit优化" tabindex="-1"><a class="header-anchor" href="#_3-5-limit优化" aria-hidden="true">#</a> 3.5 limit优化</h2><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>我们一起来看看执行limit分页查询耗时对比：</p><figure><img src="'+J+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过测试我们会看到，越往后，分页查询效率越低，这就是分页查询的问题所在。</p><p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记 录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_sku t <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> tb_sku <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">2000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> a <span class="token keyword">where</span> t<span class="token punctuation">.</span>id <span class="token operator">=</span> a<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_3-6-count优化" tabindex="-1"><a class="header-anchor" href="#_3-6-count优化" aria-hidden="true">#</a> 3.6 count优化</h2><h3 id="_3-6-1-概述" tabindex="-1"><a class="header-anchor" href="#_3-6-1-概述" aria-hidden="true">#</a> 3.6.1 概述</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p><ul><li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 <code>count(*)</code> 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p></li><li><p>InnoDB 引擎就麻烦了，它执行 <code>count(*)</code> 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p></li></ul><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。</p><h3 id="_3-6-2-count用法" tabindex="-1"><a class="header-anchor" href="#_3-6-2-count用法" aria-hidden="true">#</a> 3.6.2 count用法</h3><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。</p><p>用法：count（*）、count（主键）、count（字段）、count（数字）</p><table><thead><tr><th style="text-align:left;"><strong>count用法</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td style="text-align:left;">count(主键)</td><td>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。 服务层拿到主键后，直接按行进行累加(主键不可能为null)</td></tr><tr><td style="text-align:left;">count(字段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出 来，返回给服务层，服务层判断是否为null，不为null，计数累加。 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返 回给服务层，直接按行进行累加。</td></tr><tr><td style="text-align:left;">count(数字)</td><td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1” 进去，直接按行进行累加。</td></tr><tr><td style="text-align:left;">count(*)</td><td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接 按行进行累加。</td></tr></tbody></table><blockquote><p>按照效率排序的话，<code>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</code>，所以尽量使用 count(*)。</p></blockquote><h2 id="_3-7-update优化" tabindex="-1"><a class="header-anchor" href="#_3-7-update优化" aria-hidden="true">#</a> 3.7 update优化</h2><p>我们主要需要注意一下update语句执行时的注意事项。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">update</span> course <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;javaEE&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当我们在执行这条SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</p><blockquote><p>id是主键，是聚簇索引，所以会将行锁</p></blockquote><p>但是当我们在执行如下SQL时。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">update</span> course <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token string">&#39;SpringBoot&#39;</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">&#39;PHP&#39;</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低。</p><blockquote><p>那么字段是普通字段，没有加索引，所以对其进行更新时会加表锁，而不是行锁</p></blockquote><blockquote><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p></blockquote>`,186),G=[V];function K(Y,X){return n(),a("div",null,G)}const $=s(P,[["render",K],["__file","03 MySQL优化.html.vue"]]);export{$ as default};
