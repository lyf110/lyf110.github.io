const e=JSON.parse('{"key":"v-0897aae9","path":"/project/tjxt/notes/day04-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96.html","title":"day04-高并发优化","lang":"zh-CN","frontmatter":{"title":"day04-高并发优化","date":"2023-07-15T19:20:23.000Z","order":4,"category":["项目","天机学堂"],"tag":["项目","天机学堂"],"author":{"name":"liuyangfang","link":"https://github.com/lyf110"},"description":"day04-高并发优化 昨天我们实现了学习计划和学习进度的统计功能。特别是学习进度部分，为了更精确的记录用户上一次播放的进度，我们采用的方案是：前端每隔15秒就发起一次请求，将播放记录写入数据库。 但问题是，提交播放记录的业务太复杂了，其中涉及到大量的数据库操作： img 在并发较高的情况下，会给数据库带来非常大的压力。该怎么解决呢？ 今天我们就来分析一下，当碰到高并发的数据库写业务时，该如何优化。通过今天的学习，大家可以掌握下面的技能：","head":[["meta",{"property":"og:url","content":"https://github.com/lyf110/project/tjxt/notes/day04-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"lyf blog"}],["meta",{"property":"og:title","content":"day04-高并发优化"}],["meta",{"property":"og:description","content":"day04-高并发优化 昨天我们实现了学习计划和学习进度的统计功能。特别是学习进度部分，为了更精确的记录用户上一次播放的进度，我们采用的方案是：前端每隔15秒就发起一次请求，将播放记录写入数据库。 但问题是，提交播放记录的业务太复杂了，其中涉及到大量的数据库操作： img 在并发较高的情况下，会给数据库带来非常大的压力。该怎么解决呢？ 今天我们就来分析一下，当碰到高并发的数据库写业务时，该如何优化。通过今天的学习，大家可以掌握下面的技能："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/lyf110/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"day04-高并发优化"}],["meta",{"property":"article:author","content":"liuyangfang"}],["meta",{"property":"article:tag","content":"项目"}],["meta",{"property":"article:tag","content":"天机学堂"}],["meta",{"property":"article:published_time","content":"2023-07-15T19:20:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"day04-高并发优化\\",\\"image\\":[\\"https://github.com/lyf110/\\"],\\"datePublished\\":\\"2023-07-15T19:20:23.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"liuyangfang\\",\\"link\\":\\"https://github.com/lyf110\\"}]}"]]},"headers":[{"level":2,"title":"1.1.单机并发能力","slug":"_1-1-单机并发能力","link":"#_1-1-单机并发能力","children":[]},{"level":2,"title":"1.2.变同步为异步","slug":"_1-2-变同步为异步","link":"#_1-2-变同步为异步","children":[]},{"level":2,"title":"1.3.合并写请求","slug":"_1-3-合并写请求","link":"#_1-3-合并写请求","children":[]},{"level":2,"title":"2.1.优化方案选择","slug":"_2-1-优化方案选择","link":"#_2-1-优化方案选择","children":[]},{"level":2,"title":"2.2.Redis数据结构设计","slug":"_2-2-redis数据结构设计","link":"#_2-2-redis数据结构设计","children":[]},{"level":2,"title":"2.3.持久化思路","slug":"_2-3-持久化思路","link":"#_2-3-持久化思路","children":[]},{"level":2,"title":"3.1.延迟任务方案","slug":"_3-1-延迟任务方案","link":"#_3-1-延迟任务方案","children":[]},{"level":2,"title":"3.2.DelayQueue的原理","slug":"_3-2-delayqueue的原理","link":"#_3-2-delayqueue的原理","children":[]},{"level":2,"title":"3.3.DelayQueue的用法","slug":"_3-3-delayqueue的用法","link":"#_3-3-delayqueue的用法","children":[]},{"level":2,"title":"4.1.定义延迟任务工具类","slug":"_4-1-定义延迟任务工具类","link":"#_4-1-定义延迟任务工具类","children":[]},{"level":2,"title":"4.2.改造提交学习记录功能","slug":"_4-2-改造提交学习记录功能","link":"#_4-2-改造提交学习记录功能","children":[]},{"level":2,"title":"5.1.线程池的使用","slug":"_5-1-线程池的使用","link":"#_5-1-线程池的使用","children":[]},{"level":2,"title":"5.2.定时任务方案","slug":"_5-2-定时任务方案","link":"#_5-2-定时任务方案","children":[]},{"level":2,"title":"5.3.预习","slug":"_5-3-预习","link":"#_5-3-预习","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":23.41,"words":7024},"filePathRelative":"project/tjxt/notes/day04-高并发优化.md","localizedDate":"2023年7月16日","excerpt":"<h1> day04-高并发优化</h1>\\n<p>昨天我们实现了学习计划和学习进度的统计功能。特别是学习进度部分，为了更精确的记录用户上一次播放的进度，我们采用的方案是：前端每隔15秒就发起一次请求，将播放记录写入数据库。</p>\\n<p>但问题是，提交播放记录的业务太复杂了，其中涉及到大量的数据库操作：</p>\\n<figure><figcaption>img</figcaption></figure>\\n<p>在并发较高的情况下，会给数据库带来非常大的压力。该怎么解决呢？</p>\\n<p>今天我们就来分析一下，当碰到高并发的数据库写业务时，该如何优化。通过今天的学习，大家可以掌握下面的技能：</p>","copyright":{"author":"liu yang fang","license":"Apache License 2.0"},"autoDesc":true}');export{e as data};
